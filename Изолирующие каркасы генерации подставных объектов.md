# Изолирующие каркасы генерации подставных объектов

В этой главе:
- Что такое изолирующий каркас.
- Применение NSubstitute для создания заглушек и
подставок.
- Более сложные сценарии использования заглушек и
подставок.
- Как избежать неправильного употребления изолирующих каркасов.

В предыдущей главе мы видели, как писать заглушки и подставки
вручную и какие при этом возникают проблемы. В этой главе мы рассмотрим несколько элегантных решений подобных проблем за счет
применения изолирующих каркасов – библиотек, которые умеют создавать и настраивать поддельные объекты во время выполнения. Эти
объекты называются динамическими заглушками и подставками

Мы начнем с изложения общих сведений об изолирующих каркасах (или каркасов генерации подставных объектов, но слово «подставной» и так уже используется слишком часто) и их возможностях.
Я употребляю термин «изолирующий каркас», потому что назначение этого ПО состоит в том, чтобы изолировать единицу работы
от зависимостей. Мы подробно обсудим один конкретный каркас:
NSubstitute. Вы увидите, как его можно использовать для тестирования различных аспектов, создания заглушек, подставок и других
интересных вещей.

Но не в самом NSubstitute (для краткости NSub) дело. Знакомясь с
NSub, вы увидите, как его API поощряет и поддерживает определенные
свойства тестов (удобочитаемость, пригодность для сопровождения,
стабильность и актуальность на протяжении длительного времени и
т. д.), и поймете, когда изолирующий каркас хорош, а когда, напротив,
становится обузой.
Поэтому в конце главы я сравню NSub с другими каркасами, доступными разработчикам на платформе .NET, с точки зрения API и
их влияния на удобочитаемость, пригодность для сопровождения и
стабильность, и в заключение приведу контрольный список характеристик, на которые следует обращать внимание, принимая решение
об использовании каркаса для написания тестов.
Но начнем с самого начала: что такое изолирующий каркас?

## Зачем использовать изолирующие каркасы?

Я начну с простого определения, которое может показаться слишком
общим, но оно вынуждено быть таковым, чтобы охватить разнообразные имеющиеся каркасы.

**Определение**. Изолирующий каркас – это набор программируемых API,
благодаря которым создавать поддельные объекты становится гораздо проще, быстрее и лаконичнее, чем вручную.
 Хорошо спроектированный изолирующий каркас может избавить разработчика от необходимости снова и снова писать один и тот же код для утверждений или имитации взаимодействия объектов. А если каркас спроектирован
очень хорошо, то с его помощью можно создавать тесты, которые будут работать годами, не заставляя разработчика возвращаться к ним после малейшего изменения продуктового кода.

Изолирующие каркасы существуют для большинства языков, для
которых имеются каркасы автономного тестирования. Например, для
C++ есть mockpp и другие каркасы, для Java – jMock и PowerMock
и прочие. Для .NET существует несколько популярных каркасов:
Moq , FakeItEasy, NSubstitute, Typemock Isolator и JustMock . Есть и
другие, но я их больше не использую и о них не рассказываю, потому
что они либо устарели, либо слишком громоздки, либо не располагают возможностями, появившимися в более поздних каркасах. Это
Rhino Mocks , NMock , EasyMock , NUnit.Mocks и Moles . Каркас Moles
включен в Visual Studio 2012 под названием Microsoft Fakes, но я все
равно рекомендую держаться от него подальше. Более подробно все
эти инструменты описываются в приложении.

У создания заглушек и подставок с помощью изолирующих каркасов, а не вручную, как в предыдущих главах, есть ряд преимуществ,
которые позволяют разрабатывать более элегантные и сложные тесты быстрее, проще и с меньшим количеством ошибок.
Чтобы по-настоящему оценить полезность изолирующего каркаса,
решим с его помощью какую-нибудь задачу. Одна из проблем при создании заглушек и подставок вручную – необходимость писать повторяющийся код.
Рассмотрим интерфейс, чуть более сложный, чем нам встречались
до сих пор:

```C#
public interface IComplicatedInterface
{
 void Method1(string a, string b, bool c, int x, object o);
 void Method2(string b, bool c, int x, object o);
 void Method3(bool c, int x, object o);
}
```

На создание рукописной заглушки или подставки для такого интерфейса может уйти много времени, потому что необходимо помнить параметры каждого метода. Судите сами.

Листинг 5.1. Реализация сложного интерфейса с помощью рукописной
заглушки


```C#
class MytestableComplicatedInterface:IComplicatedInterface
{
 public string meth1_a;
 public string meth1_b,meth2_b;
 public bool meth1_c,meth2_c,meth3_c;
 public int meth1_x,meth2_x,meth3_x;
 public int meth1_0,meth2_0,meth3_0;
 public void Method1(string a, string b, bool c,
 int x, object o)
 {
 meth1_a = a;
 meth1_b = b;
 meth1_c = c;
 meth1_x = x;
 meth1_0 = 0;
 }
 public void Method2(string b, bool c, int x, object o)
 {
 meth2_b = b;
 meth2_c = c;
 meth2_x = x;
 meth2_0 = 0;
 }
 public void Method3(bool c, int x, object o)
 {
 meth3_c = c;
 meth3_x = x;
 meth3_0 = 0;
 }
}

```


Во-первых, вручную кодировать этот поддельный объект долго и
скучно. Во-вторых, что, если вы захотите проверить, что метод вызывается несколько раз? (Напомню, что в главе 4 я определил подделку как нечто, похожее на настоящий объект, но не являющееся
им. В зависимости от способа использования подделка может быть
заглушкой или подставкой.) Или если потребуется, чтобы он возвращал значение, зависящее от полученных параметров? Или если нужно запоминать значения всех параметров при каждом вызове метода
(вести историю передачи параметров)? Код очень быстро станет безобразным.
А благодаря изолирующему каркасу код, решающий все эти задачи, становится тривиальным, удобочитаемым и куда более коротким.
И мы сейчас в этом убедимся, создав свою первую динамическую
подставку.

## Динамическое создание поддельного объекта

Дадим определение динамического поддельного объекта и его отличий
от обычной рукописной подделки.

**Определение**. _Динамический поддельный объект_ – это заглушка или подставка, создаваемая во время выполнения без необходимости кодировать
реализацию вручную.

Динамические подделки устраняют необходимость вручную кодировать классы, реализующие интерфейсы или наследующие другим
классам, поскольку нужный класс можно сгенерировать автоматически во время выполнения, написав всего несколько простых строк
кода.

Теперь посмотрим, как каркас NSubstitute помогает решить некоторые из описанных выше проблем.


## Применение NSubstitute в тестах

В этой главе я буду использовать NSubstitute (http://nsubstitute.
github.com/) – бесплатный изолирующий каркас с открытым исходным кодом, который можно установить с помощью NuGet (можно
скачать с сайта http://nuget.org). Я долго думал, что взять: NSubstitute
или FakeItEasy. Оба хороши, поэтому прежде чем решать, на каком
остановиться, рекомендую ознакомиться с тем и другим. Я приведу
результаты сравнения каркасов в следующей главе и в приложении,
но уже сейчас скажу, что выбрал NSubstitute, потому что он лучше
документирован и поддерживает большую часть того, что должен
поддерживать достойный изолирующий каркас.
Краткости ради я далее буду называть NSubstitute просто NSub.
Этот каркас легко использовать, и изучение его API не займет много времени. Я рассмотрю несколько примеров, чтобы показать, как
применение каркаса облегчает труд программиста (иногда). В следующей главе мы более детально изучим некоторые «метавопросы», относящиеся к изолирующим каркасам, разберемся, как они работают,
и выясним, почему одни каркасы умеют делать вещи, которые другим
не по силам. Но это все потом, а сейчас – за дело.
Для начала создайте библиотеку классов, которая станет проектом
с автономными тестами, и добавьте ссылку на NSub, установив его
с помощью NuGet (Tools → Package Manager → Package Manager
console → Install-Package NSubstitute).
NSub поддерживает модель подготовка-действие-утверждение –
ту самую, которой мы придерживались при написании тестов до сих
пор. Идея в том, чтобы создать и настроить подделки на стадии подготовки, затем воздействовать на тестируемый продуктовый код, после
чего в утверждении проверить, что подделка вызывалась.
В NSub имеется класс Substitute , который используется для генерации подделок во время выполнения. У этого класса есть один метод For(type), предлагаемый в обычном и обобщенном исполнении;
это основной способ внедрения поддельного объекта в приложение.
При вызове этого метода указывается тип, для которого нужно создать поддельный экземпляр.
Метод динамически создает и возвращает поддельный объект, согласованный с указанным типом или интерфейсом. Вам ничего реализовывать не надо.Поскольку NSub – ограниченный каркас, лучше всего он работает
с интерфейсами. Подделать реальный класс можно, только если он
не запечатан, да и в этом случае подделываются лишь виртуальные
методы.

## Замена рукописной подделки динамической

Пусть требуется поддельный объект, который проверяет, правильно
ли произведена запись в журнал. Ниже приведен тестовый класс и
рукописная подделка, созданная без применения изолирующего каркаса.

Листинг 5.2. Утверждение относительно рукописного поддельного
объекта

```C#
[TestFixture]
class LogAnalyzerTests
{
 [Test]
 public void Analyze_TooShortFileName_CallLogger()
 {
 FakeLogger logger = new FakeLogger();
 LogAnalyzer analyzer = new LogAnalyzer(logger);
 analyzer.MinNameLength= 6;
 analyzer.Analyze(“a.txt”);
 StringAssert.Contains(“слишком короткое”,logger.LastError);
 }
}
class FakeLogger: ILogger
{
 public string LastError;
 public void LogError(string message)
 {
 LastError = message;
 }
}
```

Полужирным шрифтом выделены те части, которые изменятся при
использовании динамических заглушек и подставок.
Теперь создадим динамический подставной объект и заменим написанный ранее тест. В следующем листинге показано, как просто подделать ILogger и проверить, что ему была передана правильная
строка

Листинг 5.3. Подделка объекта с помощью NSub

```C#
[Test]
public void Analyze_TooShortFileName_CallLogger()
{
 ILogger logger = Substitute.For<ILogger>();
 LogAnalyzer analyzer = new LogAnalyzer(logger);
 analyzer.MinNameLength = 6;
 analyzer.Analyze(“a.txt”);
 logger.Received().LogError(" "
: a.txt”);
}

```

Всего две строки – и вы избавлены от необходимости вручную писать заглушку или подставку, потому что она генерируется автоматически 1. Динамически сгенерирован поддельный объект, который
реализует интерфейс ILogger, но все методы ILogger в нем – пустышки.
Начиная с этого момента и до конца теста, все обращения к поддельному объекту автоматически запоминаются, и эту информацию
можно затем проанализировать, как в последней строке.
В последней строке вместо привычного утверждения используется метод расширения, предоставляемый NSub. В интерфейсе ILogger
нет метода с именем Received(). С помощью этого метода мы утверждаем, что данный поддельный объект действительно вызывался
(и, значит, концептуально является подставкой).
То, как метод Received() работает, наводит на мысли о чуде. Он
возвращает объект того же типа, для которого был вызван, только вот
его методы используются для высказывания утверждения.
Если бы мы написали в последней строке теста просто

```C#
logger.LogError("Слишком короткое имя файла"
: a.txt”);
```

то поддельный объект рассматривал бы это обращение так, будто оно
произведено при прогоне продуктового кода, и ровным счетом ничего
не сделал бы – если, конечно, не настроить его на выполнение какогото специального действия в методе LogError.
Вызвав Received() непосредственно перед LogError(), мы сообщаем NSub о том, что нас интересует, вызывался указанный метод
объекта-подделки или нет. Если метод не вызывался, то будет возбуждено исключение. Читать это предложение следует так: «Нечто
получало (received) вызов метода, иначе этот тест не прошел бы».
Если метод LogError не вызывался, в журнале непрошедших тестов появится примерно такое сообщение об ошибке:

```C#
NSubstitute.Exceptions.ReceivedCallsException : Expected to receive a call
 matching:
 LogError(“Filename too short: a.txt”)
Actually received no matching calls.
```

Подготовка–действие–утверждение
Обратите внимание, как точно использование изолирующего каркаса соответствует схеме подготовка–действие–утверждение. Сначала мы готовим поддельный объект, затем воздействуем на то, что тестируем, а в
конце высказываем утверждение о результате.
 Но не всегда было так просто.
 Давным-давно (году эдак в 2006) большинство изолирующих каркасов
с открытым исходным кодом не поддерживало концепцию подготовка–
действие–утверждение, а работало по принципу запись–воспроизведение (record–replay).
 Это был пренеприятнейший механизм, который требовал сначала сообщить каркасу, что созданный им поддельный объект находится в режиме
записи, после чего следовало вызывать методы объекта так же, как это
должно происходить в продуктовом коде.
 Затем надо было переключить каркас в режим воспроизведения и только потом можно было отправить подделку в сердцевину продуктового
кода.
 Пример можно найти в блоге Google, посвященном тестированию: http://
googletesting.blogspot.no/2009/01/tott-use-easymock.html.
 В таких тестах утверждения обычно сводились просто к вызову метода
каркаса verify() или verifyAll() , а бедный читатель теста должен был
вернуться назад и догадаться, что же все-таки ожидалось.
 Эта трагедия стоила многим разработчикам миллионов часов усердного
чтения тестов в попытках выяснить, почему тест не проходит. Современная модель подготовка–действие–утверждение куда понятнее.
 Если у вас имеется первое издание этой книги, то вы сможете найти
пример записи–воспроизведения в разделе, посвященном каркасу Rhino
Mocks. Ах, старые добрые времена! Теперь я держусь от Rhino Mocks подальше, потому что его API не так хорош, как в новых каркасах, и потому
что Орен Эйни (http://Ayende.com) поставил его дальнейшее сопровождение под вопрос. Похоже, что Орен, который во многих отношениях заслужил репутацию суперпрограммиста, остепенился, женился и теперь
должен расставлять приоритеты. Rhino Mocks, по-видимому, в число приоритетов не входит.

Итак, вы только что видели, как использовать подделки в роли подставок. А теперь посмотрим, как они используются в роли заглушек,
имитирующих значения, получаемые тестируемой системой.

## Подделка значений

В следующем листинге показано, как вернуть значение из поддельного объекта, реализующего интерфейс, в котором есть метод, возвращающий не void. Для этого примера мы добавим в систему интерфейс
IFileNameRules (см. файл NSubBasics.cs в репозитории исходного
кода к этой книге).

Листинг 5.4. Возврат значения из поддельного объекта

```C#
[Test]
public void Returns_ByDefault_WorksForHardCodedArgument()
{
 IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
 fakeRules.IsValidLogFileName(“strict.txt”).Returns(true);
 Assert.IsTrue(fakeRules.IsValidLogFileName(“strict.txt”));
}

```

А что, если аргумент нам безразличен? С точки зрения удобства
сопровождения, было бы правильнее всегда возвращать определенное поддельное значение, каким бы ни был аргумент, потому что тогда при любом изменении внутренней структуры продуктового кода
тест все равно пройдет, даже если продуктовый код вызывает метод
несколько раз. Выиграет и понятность, потому что сейчас читатель
теста не знает, важно ли конкретное имя файла. Если вы сможете облегчить ему жизнь, не заставляя усваивать ненужную информацию,
то ему будет проще сопровождать ваш код.
Для этой цели каркас предоставляет сопоставители аргументов:

```C#
[Test]
public void Returns_ByDefault_WorksForHardCodedArgument()
{
 IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
 fakeRules.IsValidLogFileName(Arg.Any<String>()).Returns(true);
 Assert.IsTrue(fakeRules.IsValidLogFileName(“anything.txt”));
}
```

Обратите внимание, как класс Arg используется для того, чтобы
сообщить, что это поддельное значение следует возвращать при любом входном аргументе. Такие сопоставители аргументов широко используются в изолирующих каркасах для задания порядка обработки
аргументов.
А что, если требуется имитировать исключение? В NSub это делается так:

```C#
[Test]
public void Returns_ArgAny_Throws()
{
 IFileNameRules fakeRules = Substitute.For<IFileNameRules>();
 fakeRules.When(x => x.IsValidLogFileName(Arg.Any<string>()))
 .Do(context => { throw new Exception(“fake exception”); });
 Assert.Throws<Exception>(() =>
 fakeRules.IsValidLogFileName(“anything”));
}
```

Обратите внимание, как с помощью Assert.Throws проверяется,
что исключение действительно возбуждалось.
Я не в восторге от синтаксических наворотов NSub. В FakeItEasy
добиться того же результата было бы проще, но NSub лучше документирован, потому я его и выбрал.
Отметим, что лямбда-выражения здесь обязательны. В методе
When аргумент x обозначает поддельный объект, поведение которого
мы изменяем. В методе Do обратите внимание на аргумент context
типа CallInfo. Во время выполнения context содержит значения
аргументов и позволяет делать удивительные вещи, но в данном примере это не нужно.
Научившись имитировать различное поведение, перейдем к более
практическим вопросам и посмотрим, что же у нас имеется.

## Встретились в тесте подставка, заглушка и священник

Воспользуемся в одном тесте двумя видами поддельных объектов: заглушкой и подставкой.
В исходном коде к книге найдите пример Analyzer2 в папке для
главы 5. Он похож на пример в листинге 4.2 из главы 4, где речь шла
об использовании в LogAnalyzer классов MailSender и WebService,
но на этот раз требование такое: если объект-регистратор возбуждает исключение, то об этом нужно уведомить веб-службу. Схема взаимодействия показана на рис. 5.1.
Мы хотим убедиться, что если регистратор возбуждает исключение, то LogAnalyzer2 уведомит WebService о проблеме.
![loganalyser3](./images/LogAnalyser3.png)

Рис. 5.1. Вместо регистратора мы используем заглушку,
имитирующую исключение, а вместо веб-службы – подставку,
контролирующую правильность обращения. В целом тестируется
взаимодействие LogAnalyzer2 с другими объектами

В листинге ниже показан как продуктовый тест, так и его тесты.

Листинг 5.5. Тестируемый метод и тест с рукописными подставкой
и заглушкой

```C#
[Test]
public void Analyze_LoggerThrows_CallsWebService()
{
 FakeWebService mockWebService = new FakeWebService();
 FakeLogger2 stubLogger = new FakeLogger2();
 stubLogger.WillThrow = new Exception(“fake exception”);
 var analyzer2 = new LogAnalyzer2(stubLogger, mockWebService);
 analyzer2.MinNameLength = 8;
 string tooShortFileName=”abc.ext”;
 analyzer2.Analyze(tooShortFileName);
 Assert.That(mockWebService.MessageToWebService,
 Is.StringContaining(“fake exception”));
}
public class FakeWebService:IWebService
{
 public string MessageToWebService;
 public void Write(string message)

 {
 MessageToWebService = message;
 }
}
public class FakeLogger2:ILogger
{
 public Exception WillThrow = null;
 public string LoggerGotMessage = null;
 public void LogError(string message)
 {
 LoggerGotMessage = message;
 if (WillThrow != null)
 {
 throw WillThrow;
 }
 }
}
//---------- 
 
public class LogAnalyzer2
{
 private ILogger _logger;
 private IWebService _webService;
 public LogAnalyzer2(ILogger logger,IWebService webService)
 {
 _logger = logger;
 _webService = webService;
 }
 public int MinNameLength { get; set; }
 public void Analyze(string %lename)
 {
 if (%lename.Length<MinNameLength)
 {
 try
 {
 _logger.LogError(
 string.Format(“' 
  	

: {0}”,%lename));
 }
 catch (Exception e)
 {
 _webService.Write(“8
 


: “ + e);
 }
 }
 }
}
public interface IWebService
{
 void Write(string message);
}





```
А ниже показано, как тот же тест выглядит при использовании
NSubstitute.

Листинг 5.6. Предыдущий тест, переделанный с применением NSubstitute


```C#
[Test]
public void Analyze_LoggerThrows_CallsWebService()
{
 var mockWebService = Substitute.For<IWebService>();
 var stubLogger = Substitute.For<ILogger>();
 stubLogger.When(
 logger => logger.LogError(Arg.Any<string>()))
 .Do(info => { throw new Exception(“fake exception”);});
 var analyzer = new LogAnalyzer2(stubLogger, mockWebService);
 analyzer.MinNameLength = 10;
 analyzer.Analyze(“Short.txt”);
 mockWebService.Received()
 .Write(Arg.Is<string>(s => s.Contains(“fake exception”)));
}
```

В этом тесте хорошо то, что не нужны никакие рукописные подделки, однако обратите внимание, какой урон это наносит удобочитаемости. На мой вкус, все эти лямбда-выражения выглядят не слишком
дружелюбно, но это то небольшое зло, с которым приходится мириться, если хочешь работать на C#, потому что именно они позволяют не
именовать методы явно, а, значит, упростить рефакторинг в случае,
если впоследствии имя метода изменится.
Отметим, что ограничения в сопоставителях аргументов можно
использовать как на стадии подготовки, где настраивается заглушка, так и на стадии утверждения, где проверяется, вызывалась ли
подставка.
В NSubstitute существуют и другие сопоставители аргументов, все
они хорошо документированы на сайте. Эта книга не является руководством по NSub (в конце концов, для чего-то же Бог создал онлайновую документацию), поэтому если вы хотите больше узнать об API,
ступайте на страницу http://nsubstitute.github.com/help/argumentmatchers/

## Сравнение объектов и свойств

Что происходит, когда мы ожидаем получить в качестве аргумента
объект с определенными свойствами? Например, что, если в обращении к методу webservice.Write передан объект ErrorInfo , в котором заданы свойства severity и message?

```C#

[Test]
public void Analyze_LoggerThrows_CallsWebServiceWithNSubObject()
{
 var mockWebService = Substitute.For<IWebService>();
 var stubLogger = Substitute.For<ILogger>();
 stubLogger.When(logger => logger.LogError(Arg.Any<string>()))
 .Do(info => { throw new Exception(“fake exception”);});
 var analyzer = new LogAnalyzer3(stubLogger, mockWebService);
 analyzer.MinNameLength = 10;
 analyzer.Analyze(“Short.txt”);
 mockWebService.Received()
 .Write(Arg.Is<ErrorInfo>(info => info.Severity == 1000
 && info.Message.Contains(“fake exception”)));
}

```

Обратите внимание на использование стандартных конструкций C# для создания сложных сопоставителей, проверяющих один
и тот же аргумент. Мы проверяем, что в переданном аргументе
заданы вполне определенная серьезность (severity) и конкретное
сообщение.
Также отметим, как это отражается на удобочитаемости. Вообще
говоря, я замечаю, что чем больше я использую изолирующие каркасы, тем менее читаемым становится код теста, но иногда результат
получается все же приемлемым. Тут мы имеем как раз пограничный
случай. Но если бы в одном утверждении оказалось больше одного
лямбда-выражения, я задумался бы, не будет ли рукописная подделка
понятнее.
Впрочем, если вы хотите проверить что-то самым простым способом, то можно сравнить два объекта и посмотреть, не получится ли
код понятнее. Создайте объект expected с ожидаемыми свойствами
и сравните его с фактически полученным объектом, как показано
ниже.


Листинг 5.7. Сравнение объектов целиком

```C#
[Test]
public void Analyze_LoggerThrows_CallsWebServiceWithNSubObjectCompare()
{
 var mockWebService = Substitute.For<IWebService>();
 var stubLogger = Substitute.For<ILogger>();
 stubLogger.When(logger => logger.LogError(Arg.Any<string>()))
 .Do(info => { throw new Exception(“fake exception”);});
 var analyzer = new LogAnalyzer3(stubLogger, mockWebService);
 analyzer.MinNameLength = 10;
 analyzer.Analyze(“Short.txt”);
 var expected = new ErrorInfo(1000, “fake exception”);
 mockWebService.Received().Write(expected);
}

```

Проверка объекта целиком работает при выполнении следующих
условий:
• создать объект с ожидаемыми свойствами просто;
• мы хотим проверять все свойства объекта;
• точно известны значения каждого свойства;
• в классе сравниваемых объектов корректно реализован метод
Equals(). (Вообще говоря, не стоит полагаться на готовую реализацию метода object.Equals(). Если вы не реализовали
метод Equals() самостоятельно, то этот тест никогда не пройдет, потому что реализация Equals() по умолчанию вернет
false.)
И еще одно замечание о стабильности данного теста. Поскольку
эта техника не позволяет спросить, содержит ли значение некоторого
свойства некоторую подстроку, то тесты оказываются несколько более хрупкими в плане будущих изменений.
Кроме того, если впоследствии ожидаемое строковое значение
свойства изменится, пусть даже всего на один лишний пробел в начале или в конце, то тест не пройдет и придется сопоставлять значение с новой строкой. Искусство состоит в том, чтобы решить, в
какой мере вы готовы пожертвовать удобочитаемостью ради стабильности. Лично мне кажется, что если свойств немного, то их
сравнение с помощью сопоставителей аргументов чуть более предпочтительно, чем сравнение объектов целиком, поскольку так мы получаем большую стабильность. Я терпеть не могу изменять тесты
без веских причин.

## Тестирование операций, связанных с событием

События – это улица с двусторонним движением, и тестировать их
можно в двух направлениях:
• проверить, что кто-то прослушивает событие;
• проверить, что кто-то генерирует событие.

## Тестирование прослушивателя события

Сначала рассмотрим сценарий, который, на мой взгляд, многие разработчики плохо реализуют в тестах: проверка того, что один объект
зарегистрирован в качестве получателя события от другого объекта.
Часто разработчики выбирают неудобный для сопровождения и
избыточно специфицированный способ: проверяют внутреннее состояние объекта-получателя.
Такую реализацию я никому не рекомендую в реальных тестах.
Подписка на событие – внутреннее закрытое поведение кода. Само
по себе оно не может считаться конечным результатом, а приводит к
изменению состояния, а, значит, и поведения системы.
Для проверки лучше убедиться, что объект-прослушиватель действительно что-то делает в ответ на сгенерированное событие. Если
прослушиватель не подписался на событие, то никакого видимого
изменения в поведении не будет, что иллюстрируется в следующем
листинге.


Листинг 5.8. Как вызвать выполнение кода обработки события

```C#
class Presenter
{
 private readonly IView _view;
 public Presenter(IView view)
 {
 _view = view;
 this._view.Loaded += OnLoaded;

 }
 private void OnLoaded()
 {
 _view.Render(“Hello World”);
 }
}
public interface IView
{
 event Action Loaded;
 void Render(string text);
}
//------ \6'\^
[TestFixture]
public class EventRelatedTests
{
 [Test]
 public void ctor_WhenViewIsLoaded_CallsViewRender()
 {
 var mockView = Substitute.For<IView>();
 Presenter p = new Presenter(mockView);
 mockView.Loaded += Raise.Event<Action>();
 mockView.Received()
 .Render(Arg.Is<string>(s => s.Contains(“Hello World”)));
 }
}

```

Отметим следующие моменты.
• Подставка является также заглушкой (мы имитируем событие).
• Чтобы сгенерировать событие в тесте, на него надо подписаться. Конструкция выглядит нелепо, но она необходима, чтобы
компилятор не ругался, поскольку свойства, относящиеся к
событиям, обрабатываются специальным образом и бдительно
охраняются компилятором. Напрямую генерировать событие
может только класс или структура, в которой событие объявлено.
Ниже рассмотрен еще один сценарий, в котором есть две зависимости: регистратор и представление. Тест в следующем листинге
проверяет, что объект Presenter пишет в журнал после получения
события ошибки от нашей заглушки.

Листинг 5.9. Имитация события и другая подставка


```C#
[Test]
public void ctor_WhenViewhasError_CallsLogger()
{
 var stubView = Substitute.For<IView>();
 var mockLogger = Substitute.For<ILogger>();
 Presenter p = new Presenter(stubView, mockLogger);
 stubView.ErrorOccured +=
 Raise.Event<Action<string>>(“fake error”);
 mockLogger.Received()
 .LogError(Arg.Is<string>(s => s.Contains(“fake error”)));
}
```

Отметим, что для генерации события используется заглушка 1,
а для проверки того, что служба получила сообщение, – подставка 2.
Теперь рассмотрим противоположную сторону сценария тестирования. Мы хотим проверить, что источник действительно генерирует
событие в нужное время. В следующем разделе показано, как это делается.

## Тестирование факта генераци события
Самый простой способ протестировать событие – вручную подписаться на него в тестовом методе, воспользовавшись анонимным делегатом. Ниже приведен пример.

Листинг 5.10. Использование анонимного делегата для подписки
на событие

```C#
[Test]
public void EventFiringManual()
{
 bool loadFired = false;
 SomeView view = new SomeView();
 view.Load+=delegate
 {
 loadFired = true;
 };
 view.DoSomethingThatEventuallyFiresThisEvent();
 Assert.IsTrue(loadFired);
}
```

Делегат просто запоминает, что событие имело место. Я решил использовать делегат, а не лямбда-выражение, потому что такая запись
кажется мне более понятной. У делегата могут быть также параметры,
которые тоже можно запомнить и затем проверить в утверждении.
Далее мы дадим краткий обзор изолирующих каркасов на платформе .NET.

## Современные изолирующие каркасы для .NET

NSub, конечно, не единственный имеющийся изолирующий каркас.
В неформальном опросе, проведенном в августе 2012 года, я задавал
читателям своего блога вопрос: «Каким изолирующим каркасом вы
пользуетесь?» Результаты представлены на рис. 5.2.
Каркас Moq, который на момент предыдущего издания был новичком, теперь выбился в лидеры, тогда как Rhino Mocks отстал и продолжает терять позиции (в основном, потому что активная разработка прекратилась). Кроме того, по сравнению с первым изданием
увеличилось число конкурентов – вдвое. Это кое-что говорит о зрелости сообщества в плане осознания потребности в тестировании и
изоляции, и мне отрадно это видеть.
Каркас FakeItEasy, о котором его создатель, наверное, даже не помышлял, когда вышло первое издание этой книги, теперь стал сильным конкурентом в тех аспектах, которые мне нравятся в NSubstitute,
и я горячо рекомендую поэкспериментировать с ним. Эти аспекты
(точнее сказать, полезные качества) перечислены в следующей главе,
где мы углубимся во внутренние механизмы работы изолирующих
каркасов.
Лично я не пользуюсь Moq из-за плохих сообщений об ошибках и
слишком частого употребления слова «mock» в API. Это только вводит в заблуждение, потому что «подставки» используются также для
создания заглушек.
Вообще говоря, я считаю правильным выбрать какой-то один каркас и по возможности сохранять ему верность – это повышает удобочитаемость и упрощает обучение членов команды.
В приложении к книге я рассматриваю все упомянутые каркасы
более детально и объясняю, чем они мне нравятся или не нравятся.
Суммируем преимущества изолирующих каркасов по сравнению с
рукописными подставками. А затем обсудим, на что обращать внимание при использовании изолирующих каркасов.

### Почему не следует использовать строковые имена методов в тестах

Во многих каркасах за пределами мира .NET принято с помощью строк
описывать методы, поведение которых мы собираемся изменить. Почему
это плохо?
 Если мы изменим имя метода в продуктовом коде, то все тесты, в которых этот метод используется, будут по-прежнему компилироваться, а об
ошибке сообщат только во время выполнения, возбудив исключение изза того, что метод не найден.
 При использовании строго типизированных имен методов (благодаря
лямб да-выражениям и делегатам) изменение имени не приводит к проблемам, потому что метод определен прямо в тесте. После любого нескоординированного изменения тест просто перестанет компилироваться, и
мы сразу узнаем, что в нем имеется ошибка.
Автоматизированные средства рефакторинга, в том числе встроенные в
Visual Studio, упрощают переименование методов, но строки в исходном
коде при этом как правило все равно не анализируются. (ReSharper для
.NET в этом смысле исключение. Он исправляет также и строки, но это
лишь частичное решение, которое к тому же в некоторых случаях само может стать причиной ошибок.)

## Достоинства и подводные камни изолирующих каркасов

Из сказанного в этой главе очевидны следующие достоинства изолирующих каркасов.

- Упрощается проверка параметров . Использование рукописных подставок для проверки того, что методу переданы правильные параметры, – утомительный процесс, требующий
времени и терпения. В большинстве изолирующих каркасов
проверка переданных параметров, даже если их много, – тривиальная процедура.

- Упрощается контроль нескольких обращений к методу. При
использовании рукописных подставок трудно проверить, что
один и тот же метод вызывался несколько раз с правильными
параметрами. Как мы увидим ниже, в изолирующих каркасах
эта проверка также тривиальна.

## Каких подводных камней избегать при использовании изолирующих каркасов

Несмотря на все достоинства изолирующих каркасов, существуют и
опасности, например, безудержное использование каркасов в случаях, когда вполне хватило бы и рукописной подставки; создание тестов, которые трудно читать из-за чрезмерного изобилия подставок,
или недостаточно тщательное разделение тестов.

Вот перечень моментов, на которые следует обращать особое внимание:

- неудобочитаемый тестовый код;
- проверка не того, что надо;
- наличие более одной подставки в одном тесте;
- избыточное специфицирование теста

Рассмотрим каждый вопрос более детально.

## Неудобочитаемый тестовый код

Наличие подставки в тесте и так уже делает его менее понятным, но
все же не настолько, чтобы сторонний читатель не мог разобраться,
что в нем происходит. Наличие нескольких подставок или нескольких ожиданий в одном тесте может снизить удобочитаемость до такого уровня, что будет трудно не только сопровождать его, но хотя бы
понять, что именно тестируется.
Если вы замечаете, что тест становится неудобочитаемым или за
его кодом трудно следить, попробуйте убрать некоторые подставки
или ожидания либо разделить тест на несколько меньших и более понятных.

## Проверка не того, что надо

Подставные объекты позволяют проверить, что вызывались методы,
объявленные в интерфейсе, но это еще не означает, что вы тестируете
то, что надо. Проверка того, что объект подписан на событие, ничего не говорит о функциональности объекта. Для тестирования этого
объекта лучше бы проверить, что после возникновения события произошло что-то значимое.

## Наличие более одной подставки в одном тесте

Считается правильным тестировать в каждом тесте только один аспект, в противном случае может возникнуть путаница и трудности с
сопровождением теста. Наличие двух подставок в одном тесте – то
же самое, что тестирование нескольких конечных результатов одной
и той же единицы работы. Если вы не можете придумать тесту имя,
потому что он делает слишком много сразу, то следует разделить его
на несколько тестов.

##  Избыточное специфицирование теста

Старайтесь обходиться без подставных объектов. Тест, в котором нет
утверждений относительно вызова какого-то объекта, проще читать и
сопровождать. Да, бывают случаи, когда цели можно достичь только с
помощью подставок, но их не должно быть слишком много.
Если более 5 % ваших тестов завязаны на подставки (не заглушки),
то, вероятно, вы увлеклись избыточным специфицированием вместо проверки изменения состояния или возвращаемых значений. Но
даже и в 5 % тестов, где используются подставные объекты, можно
перегнуть палку.
Тест, в котором слишком много ожиданий (x.received().X() и
X.received().Y() и т. д.), может оказаться очень хрупким и отказать
при малейшем изменении продуктового кода, хотя функциональность последнего не нарушена.
Тестирование взаимодействий – палка о двух концах: если проверяется слишком много, то за деревьями становится трудно рассмотреть лес – общую функциональность, а если слишком мало, то можно
упустить из виду существенные взаимодействия объектов.

Приведу несколько рекомендаций по поиску компромисса.
- По возможности используйте нестрогие подставки (что такое строгие и нестрогие подставки, объясняется в следующей
главе). Тогда тест будет реже отказывать из-за неожиданных
вызовов методов. Это помогает, когда закрытые методы в продуктовом коде продолжают изменяться.
- По возможности используйте заглушки вместо подставок.
Если подставки встречаются более чем в 5 % тестов, то это,
скорее всего, перебор. Заглушки можно вставлять повсюду, с
подставками надо быть скромнее. Тестировать следует только один сценарий в каждом тесте. Чем больше подставок, тем
больше проверок будет в конце теста, но важной обычно является только одна. Остальные – просто шум, затемняющий
смысл текущего тестового сценария.
Избегайте заглушек в роли подставок, если это в человеческих силах. Используйте заглушку только для подделывания
значений, возвращаемых тестируемой программе, или для
возбуждения исключений. Не проверяйте, вызывались ли какие-то методы заглушки. Чтобы проверить факт обращения к
методу, используйте подставку, но возвращать значения в тестируемую программу она не должна. По большей части можно
избежать использования подставок, одновременно выступающих в роли заглушек, но не всегда (как мы видели в примере,
касающемся событий, выше в этой главе).

## Выводы

Изолирующие каркасы – отличная штука, и вы обязательно должны
научиться с ними работать. Но по возможности предпочитайте тестирование на основе проверки возвращаемых значений и изменения состояния (в противоположность тестированию взаимодействий), поскольку в этом случае в тестах содержится минимум предположений
о внутренних деталях реализации. К подставкам следует прибегать
только тогда, когда нет никакого другого способа протестировать реализацию, поскольку в результате получаются тесты, которые труднее
сопровождать.
Если подставки (не заглушки) встречаются более чем в 5 % тестов,
то, скорее всего, вы увлеклись избыточным специфицированием.
Изучайте продвинутые средства изолирующих каркасов, в частности NSub, – и тест сможет достоверно сказать, что происходит, а
чего не происходит в программе. Нужно лишь, чтобы код был тестопригодным.
Можно также навредить себе, создавая избыточно специфицированные тесты, которые трудно читаются и легко ломаются. Умение
принять правильное решение о том, когда использовать динамические, а когда рукописные подставки – это искусство. Мой совет: если
код с применением изолирующего каркаса начинает казаться безобразным, значит, пора что-то упрощать. Напишите подставку вручную
или проверьте другой результат, который доказывает то же самое, но
проще.
Если, несмотря на все усилия, код все равно трудно протестировать, то остается три варианта: воспользоваться суперкаркасом типа
Typemock Isolator (рассматривается в следующей главе), изменить
проект или бросать работу.
Изолирующие каркасы могут существенно упростить процесс тестирования и помочь в создании тестов, удобных для чтения и сопровождения. Но важно понимать, что иногда они не столько помогают,
сколько мешают разработке. Например, при работе с унаследованным кодом, возможно, придется воспользоваться другим каркасом, с
иными возможностями. Для каждой работы нужен свой инструмент, поэтому обдумывая, как подойти к решению конкретной проблемы
тестирования, обязательно оценивайте общую картину.
В следующей главе мы глубже копнем изолирующие каркасы, рассмотрев их внутреннее устройство и его влияние на спектр предоставляемых возможностей.


