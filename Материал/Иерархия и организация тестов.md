# Иерархии и организация тестов

В этой главе:
 - Прогон автономных тестов во время ночной автоматизированной сборки.
 - Использование непрерывной интеграции для автоматизированной сборки.
 - Организация тестов в решении.
 - Паттерны наследования тестовых классов.

Автономные тесты важны для приложения не менее, чем продуктовый код. И точно так же следует тщательно продумывать, как разместить тесты – физически и логически – относительно тестируемого
кода. Если поместить автономные тесты в неподходящее место, то все
старания могут оказаться тщетны – тесты не запустятся.
Аналогично, если вы не придумаете, как повторно использовать
части тестов, не создадите служебных методов для тестирования, не
будете организовывать тесты иерархически, то код тестов будет невозможно ни понять, ни сопровождать.
В этой главе мы рассмотрим паттерны и рекомендации, которые
помогут вам определить, как тесты должны выглядеть, выполняться
и при этом органично интегрироваться с продуктовым кодом и другими тестами.
Куда помещать тесты, зависит от того, где они будут использоваться и как запускаться. Существует два сценария: прогон тестов в составе автоматизированной процедуры сборки и локально разработчиком
на его машине. Автоматизированная сборка – дело очень важное, поэтому с нее и начнем.

## Прогон автоматизированных тестов в ходе автоматизированной сборки

Эффективность автоматизированной процедуры сборки никак не
следует игнорировать. Я занимаюсь автоматизацией сборки и доставки больше десяти лет, и это один из важнейших факторов, благодаря
которым моя команда продуктивнее работает и быстрее получает обратную связь. Всякий, кто хочет сделать свою команду более гибкой
и оснащенной для своевременного реагирования на изменения требований, должен позаботиться о следующих вещах.

- Вносить изменения в код понемногу.
- Прогонять все тесты, чтобы иметь гарантию, что написанное
ранее по-прежнему работает.
- Следить за тем, чтобы при интеграции кода не возникало ошибок и не повреждались другие проекты, от которых код зависит.
- Организовать процедуру создания передаваемого пакета и автоматического развертывания одним нажатием кнопки.

По всей вероятности, чтобы решить указанные задачи, вам потребуется несколько конфигураций и скриптов сборки. Скрипты сборки
должны располагаться в системе управления версиями вместе с исходным продуктовым кодом. Они вызываются сервером непрерывной интеграции в соответствии с его конфигурацией.
Некоторые скрипты сборки запускают тесты, особенно те, что активируются сразу после записи нового кода в систему управления
версиями (СУВ). Прогон тестов позволяет узнать, работает ли новый
или уже существующий код, написанный вами или еще кем-то. Вы
интегрируете свой код с другими проектами. Тесты должны показать,
не сломалось ли что в вашем коде или в том, что логически зависит
от него. Делая это автоматически при каждом сохранении в СУВ, вы
запускаете процесс непрерывной интеграции. Что это означает, я расскажу в разделе 7.1.2.
Если бы вы интегрировали код лично, то, наверное, делали бы следующее:
- извлекли бы последние версии кода, написанного всеми участниками проекта, из репозитория системы управления версиями;
- попытались бы откомпилировать весь код на своей машине;
- локально прогнали бы все тесты;
- исправили бы все обнаруженные ошибки;
- записали бы новые версии кода в СУВ.

Для автоматизации этой работы существуют инструменты, а именно скрипты автоматизированной сборки и серверы непрерывной интеграции.

Процедура автоматизированной сборки собирает все эти шаги под
одной логической крышей, на которой можно было бы повесить вывеску «как мы здесь выпускаем код». Процедура сборки – это совокупность скриптов сборки, автоматизированных триггеров, сервера,
возможно, агентов сборки (которые и выполняют фактическую работу) и принимаемое всеми членами команды соглашение работать
таким способом.

Смысл соглашения в том, что все понимают последовательность
шагов, обязательных для того, чтобы все это работало настолько
непрерывно и автоматически, насколько возможно и необходимо
(иногда не требуется автоматически развертывать систему на производственной машине без участия человека), и готовы эти шаги выполнять.
Если в процессе сборки обнаруживается ошибка, сервер может
уведомить заинтересованные стороны о прерывании сборки.
Уточним: процесс сборки – это логическое понятие, охватывающее
скрипты сборки, серверы непрерывной интеграции, триггеры сборки
и понимаемое и поддерживаемое всеми членами команды соглашение о развертывании и интеграции.

## Анатомия скрипта сборки

У меня обычно образуется несколько скриптов сборки, каждый из которых служит одной какой-то цели. При такой организации процесс
сборки оказывается более удобным для сопровождения и целостным.
Скрипты бывают следующих видов:

- скрипт сборки непрерывной интеграции (НИ-сборки);
- скрипт ночной сборки;
- скрипт развертываемой сборки.

Я предпочитаю их разделять, потому что рассматриваю скрипты
сборки как небольшие функции, которые можно вызывать с параметрами, подавая на вход текущую версию исходного кода. А вызывающей стороной является сервер НИ.

Скрипт НИ-сборки как минимум компилирует текущий исходный
код в отладочном режиме и прогоняет все автономные тесты. В принципе, он может прогонять и другие тесты, если они работают достаточно быстро. Предполагается, что скрипт НИ-сборки дает максимум
информации в кратчайшие сроки. Чем он быстрее, тем раньше вы узнаете, что, скорее всего, ничего не сломали и можете работать дальше.

Скрипт ночной сборки обычно работает дольше. Я предпочитаю
запускать его сразу после НИ-сборки, чтобы получить дополнительную информацию, но не жду, пока он завершится, а продолжаю себе
кодировать. Он занимает больше времени, потому что должен выполнить операции, которые для НИ-сборки сочтены несущественными
или не настолько важными, чтобы включать их в цикл НИ с быстрой
обратной связью. К таким операциям можно отнести едва ли не все
что угодно, но обычно сюда входит компиляция в выпускном режиме,
прогон всех медленных тестов и, возможно, развертывание в тестовой
среде в преддверье следующего дня.

Я называю эти сборки ночными, но вообще-то их можно запускать
много раз в день. Один раз ночью – это необходимый минимум. Такие
сборки дают больше информации, но для ее сбора требуется и больше
времени.

Скрипт развертываемой сборки – это, по существу, механизм доставки. Он запускается сервером НИ и может содержать как простейшую команду xcopy копирования на удаленный сервер, так и сложную
процедуру развертывания на сотнях серверов, повторной инициализации экземпляров Azure или Amazon Elastic Compute Cloud (EC2) и
объединения баз данных.

Все сборки обычно извещают пользователя по электронной почте о
факте прерывания из-за ошибки, но самым главным и обязательным
получателем такого уведомления является сторона, запустившая
скрипты сборки: сервер непрерывной интеграции.

Существует много инструментов, помогающих в создании автоматизированных систем сборки. У одних исходный код открыт, другие
просто бесплатны, третьи поставляются на коммерческих условиях.
Ниже перечислены некоторые такие инструменты.

Создание скриптов сборки:

- NAnt (nant.sourceforge.net)
- MSBuild (www.infoq.com/articles/MSBuild-1)
- FinalBuilder (www.FinalBuilder.com)
- Visual Build Pro (www.kinook.com)
- Rake (http://rake.rubyforge.org/ )

Серверы непрерывной интеграции :

- CruiseControl.NET (cruisecontrol.sourceforge.net)
- Jenkins (http://jenkins-ci.org/)
- Travis CI (http://about.travis-ci.org/docs/user/getting-started/)
- TeamCity (JetBrains.com)
- Hudson (http://hudson-ci.org/)
- Visual Studio Team Foundation Service (http://tfs.visualstudio.
com/)
- ThoughtWorks Go (www.thoughtworks-studios.com/go-agilerelease-management)
- CircleCI (https://circleci.com/), если вы работаете только через github.com
- Bamboo (www.atlassian.com/software/bamboo/overview)

В некоторые серверы НИ встроены средства создания задач, относящихся к скриптам сборки. Я стараюсь не пользоваться такими
средствами, потому что хочу, чтобы действия скриптов сборки зависели от версии (или чтобы скрипты хранились в системе управления
версиями), тогда я в любой момент смогу вернуться к любой версии
исходных кодов и выполнить сборку, привязанную именно к этой
версии.

Из перечисленных инструментов мне больше всего нравятся FinalBuilder и TeamCity. Если бы FinalBuilder не было (а он существует
только на платформе Windows), то я бы взял Rake, потому что терпеть
не могу использовать XML для управления сборкой, т. к. он здорово
затрудняет сопровождение скриптов. Rake – зона, свободная от XML,
тогда как MSBuild и NAnt пичкают вас XML’ем до такой степени, что
теги будут сниться еще несколько месяцев. Каждый из перечисленных
инструментов особенно блистает в каком-то одном деле, хотя авторы
TeamCity добавляют все больше и больше встроенных задач, и мне
кажется, что получающиеся в результате скрипты сборки становятся
менее удобными для сопровождения.

## Запуск сборки и интеграции

Мы уже упомянули о непрерывной интеграции, а теперь рассмотрим
ее более формально. Понимать этот термин следует буквально – процесс автоматической сборки и интеграции происходит непрерывно.
Например, определенный скрипт сборки может запускаться всякий
раз, как кто-то добавляет в систему новый исходный код, или раз в
45 минут или сразу по завершении предыдущего скрипта сборки.

Основные задачи сервера НИ таковы:
- запускать скрипт сборки по определенным событиям;
- предоставлять скрипту сборки контекст и данные, например:
номер версии, исходный код, артефакты других сборок, параметры сборки и т. д.;
- предоставлять историю сборки и метрики;
- информировать о текущем состоянии активных и неактивных
сборок.

Сначала рассмотрим события-триггеры, по которым автоматически запускается скрипт сборки. Это может быть изменение в системе
управления версиями, наступление некоторого момента времени или
успешное или неудачное завершение другого скрипта сборки. Сервер
НИ позволяет настроить несколько триггеров для запуска единицы
работы. Единицы работы в этом контексте часто называют конфигурациями сборки.
В конфигурации сборки задаются исполняемые команды, например:
выполнить определенную программу, откомпилировать и т. д. Я рекомендую ограничиться запуском исполняемого файла, который выполняет скрипт сборки, хранящийся в СУВ, чтобы обеспечить максимальную
совместимость с текущей версией исходного кода. Например, TeamCity
позволяет включать шаги сборки в конфигурацию. Шаг сборки может
принимать различные формы. Например, это может быть выполнение
команды DOS или компиляция SLN-файла для .NET. Я не пользуюсь
ничем, кроме простого шага запуска пакетного файла или скрипта сборки, который извлечен из СУВ агентом сборки вместе с исходным кодом.
У конфигурации сборки может быть контекст. Контекст может
содержать много всего, но как правило в него входит текущий снимок исходного кода, извлеченного из системы управления версиями.
В контекст могут также включаться переменные окружения, необходимые скрипту сборки, или параметры, непосредственно задаваемые
в командной строке. В состав контекста могут входить и копии артефактов, оставшихся от предыдущего запуска той же или какой-то
другой конфигурации сборки. Артефактом называется конечный результат выполнения скрипта сборки. Это могут быть двоичные файлы, конфигурационные файлы и вообще файлы любого типа.
У конфигурации сборки может быть история. Мы можем узнать,
когда она запускалась, сколько времени работала и когда в последний раз завершилась успешно. Можно также узнать, сколько было
выполнено тестов и какие тесты не прошли. Что именно включается
в историю, зависит от сервера НИ.

У сервера НИ обычно имеется инструментальная панель, на которой показывается текущее состояние сборок. Некоторые серверы
даже позволяют создавать нестандартный HTML и JavaScript-код,
который можно разместить на страницах компании в интранете для
настройки отображения состояния. В состав некоторых серверов НИ
входят средства интеграции, которые работают на персональном компьютере, ведут непрерывный мониторинг состояния сборки и уведомляют пользователя об аварийном прерывании сборки.

**Дополнительные сведения об автоматизации сборки**
 Есть немало полезных рекомендаций, с которыми неплохо бы познакомиться, но они выходят за рамки этой книги. Читателю, желающему больше узнать о непрерывной интеграции, я рекомендую книги Jez Humble,
David Farley «Continuous Delivery» (Addison-Wesley Professional, 2010) и
Paul Duvall, Steve Matyas, Andrew Glover «Continuous Integration»1 (Addison-Wesley Professional, 2007). Возможно, вас заинтересует и написанная
мной книга на эту тему «Beautiful Builds». Это моя попытка создать язык
паттернов для описания типичных проблем и решений в области процесса
сборки. Ее текст опубликован на сайте www.BeautifulBuilds.com.

## Распределение тестов по скорости и типу

Совсем нетрудно прогнать тесты, измерить время выполнения каждого и решить, какие отнести к автономным, а какие – к интеграционным. Сделав это, поместите тесты в разные места. Необязательно
заводить для них отдельные проекты, достаточно разных папок и пространств имен.
На рис. 7.1 показана простая структура папок внутри одного проекта Visual Studio. В некоторых компаниях считают, что проще заводить разные проекты для автономных и интеграционных тестов;
это зависит от используемой системы сборки и каркаса автономного
тестирования. При такой организации проще работать с командными программами, которые принимают на входе сборку, содержащую
только тесты одного вида, и прогоняют их. На рис. 7.2 показано, как
можно организовать два проекта с тестами в одном решении.

![распеределиен](./images/распределение1.png)

Интеграционные
и автономные тесты могут
находиться в разных папках и
пространствах имен, оставаясь
при этом в одном проекте.
Для базовых классов заведена
отдельная папка

![распеределиен](./images/распределение2.png)

Для автономных
и интеграционных тестов,
относящихся к проекту LogAn,
заведены отдельные проекты
с разными пространствами
имен

Даже если вы еще не настроили автоматизированную систему сборки, отделить автономные тесты от интеграционных все равно полезно.
Смешение тестов обоих видов может повлечь за собой серьезные последствия, например, другие члены команды не станут прогонять ваши
тесты. Об этой проблеме мы и поговорим в следующем разделе.

## Разделение автономных и интеграционных тестов и человеческий фактор

Я рекомендую разделять автономные и интеграционные тесты. Если
этого не сделать, велик риск, что разработчики не будут прогонять тесты достаточно часто. Казалось бы – если тесты существуют, то почему
бы не прогонять их так часто, как необходимо? Одна из причин – лень
или работа в условиях катастрофической нехватки времени.
Допустим, что разработчик, выгрузивший последнюю версию исходного кода, обнаружил, что какой-то автономный тест не проходит.
Возможно несколько причин:

- в тестируемом коде ошибка;
- тест написан неправильно;
- тест уже не актуален;
- для прогона теста необходимо что-то настроить.

Во всех случаях, кроме последнего, у разработчика имеются достаточные основания, чтобы прерваться и изучить код. Последний же
случай к разработке отношения не имеет; это проблема конфигурации, которая часто считается менее важной, потому что мешает прогону тестов. Если такой тест не проходит, разработчик просто игнорирует ошибку и переходит к другим делам (у всех ведь есть «более
важные» занятия).
Наличие в составе автономных тестов таких скрытых интеграционных тестов с неизвестными или неожиданными требованиями к
настройке (например, подключение к базе данных) плохо с разных
точек зрения. Такие тесты сложнее прогонять, они отвлекают время
и деньги на поиск несуществующих проблем и вообще уменьшают
доверие разработчика к комплекту тестов. Они, как гнилое яблоко в
корзине, портят все остальные. В следующий раз, когда случится чтото подобное, разработчик, возможно, даже не захочет искать причину
ошибки, а просто скажет: «А, этот тест иногда падает, это нормально».

Чтобы такого не было, можно создать безопасную зеленую зону.

## Безопасная зеленая зона

Размещайте свои интеграционные и автономные тесты в разных местах. Тем самым вы предоставляете другим членам команды безопасную зеленую зону, содержащую только автономные тесты. И все знают, что могут взять последнюю версию кода, прогнать все тесты из
соответствующей папки или пространства имен, и все тесты при этом
должны быть зелеными. Если какой-то тест из безопасной зеленой
зоны не проходит, то имеет место реальная проблема, а не ошибка в
настройках.
Это не означает, что интеграционные тесты вообще не нужно прогонять. Но поскольку они по сути своей работают дольше, то, скорее
всего, разработчики будут прогонять автономные тесты несколько
раз в день, а интеграционные реже, но уж во время ночной сборки –
обязательно. Разработчик может сосредоточиться на своей работе, и,
если автономные тесты проходят, то у него будет ощущение уверенности – пусть даже неполной. Во время ночной сборки должны быть
выполнены все автоматизированные задачи, которые настраивают
среду, так чтобы интеграционные тесты проходили.
Кроме того, создание отдельной интеграционной зоны (в отличие
от безопасной зеленой) – это не только место, где медленные интеграционные тесты проходят карантин, сюда же можно поместить документацию по настройке, которую нужно выполнить, чтобы эти тесты
работали.
Автоматизированная система сборки настроит все сама. Но если
вы хотите прогонять тесты локально, то должны завести в своем решении или проекте интеграционную зону, в которой хранится вся информация о том, что нужно сделать для успешного прогона. Однако
если требуется выполнить только быстрые тесты (в безопасной зеленой зоне), то в интеграционную можно не заглядывать.
Впрочем, все это неактуально, если вы не храните свои тесты в системе управления версиями. Об этом мы и поговорим ниже.

## Тесты должны храниться в системе управления версиями

Тесты должны храниться в системе управления версиями. Написанный вами тестовый код должен находиться в ее репозитории наряду
с продуктовым. Вообще к тестам следует относиться столько же внимательно, как к продуктовому коду. Они должны присутствовать в
каждой ветви дерева версий и извлекаться автоматически вместе с
последней версией.
Поскольку автономные тесты так тесно связаны с кодом и API, они
всегда должны сохранять привязку к версии кода, который тестируют. Получить версию 1.0.1 продукта значит получить и версию 1.0.1
тестов для него. В версии 1.0.2 код продукта и тестов будет другим.
Кроме того, только благодаря хранению тестов в СУВ процедуры
автоматизированной сборки вообще могут надежно применять текущую версию тестов к вашему продукту.
Но если мы установили, что тесты – часть СУВ, то где именно они
должны находиться?

## Соответствие между тестовыми классами и тестируемым кодом

Структура и размещение тестовых классов должны быть устроены
так, чтобы можно было легко решить следующие задачи:

- найти все тесты, относящиеся к конкретному проекту;
- найти все тесты, относящиеся к конкретному проекту;
- найти все тесты, относящиеся к конкретному проекту;

Существует несколько паттернов, помогающих обустроить тесты
таким образом.

## Соответствие между тестами и проектами

Я предпочитаю создавать отдельный проект для тестов и называть его
так же, как тестируемый проект, с добавлением суффикса .UnitTests.
Например, для проекта Osherove.MyLibrary я бы завел еще проекты
Osherove.MyLibrary.UnitTests, Osherove.MyLibrary.IntegrationTests
и, быть может, еще что-то в том же духе (пример см. на рис. 7.2). Пусть
грубовато, зато интуитивно понятно и позволяет легко найти все
тесты, относящиеся к конкретному проекту.
Возможно, вы захотите воспользоваться имеющейся в Visual Studio
возможностью создавать папки внутри решения и поместить всю эту
троицу в отдельную папку, но это уже дело вкуса.

## Соответствие между тестами и классами

Существует несколько подходов к установлению соответствия между
тестами и тестируемыми классами. Рассмотрим два наиболее распространенных: один тестовый класс на каждый тестируемый и несколько тестовых классов для сложных тестируемых методов.

Совет. Этими двумя паттернами я пользуюсь чаще всего, но существуют
и другие. Подробнее о них можно прочитать в книге Джерарда Мезароша
«Шаблоны тестирования xUnit. Рефакторинг кода тестов».

## Один тестовый класс на каждый тестируемый класс или единицу работу

Чтобы быстро найти все тесты для конкретного класса, можно применить решение, очень похожее на описанное выше для проектов: создать в тестовом проекте класс с таким же именем, как у тестируемого
класса, и суффиксом UnitTests. Для класса LogAnalyzer тестовый
класс в тестовом проекте назывался бы LogAnalyzer.UnitTests.
Обратите внимание на множественное число: в этом классе будет
несколько тестов для тестируемого класса. Точность важна. Когда
речь идет о тестировании, удобочитаемость и ясность языка много
значат, а если вы начнете срезать углы в одном месте, то захотите
поступить так же и в других и в конце концов проблем не оберетесь.
Паттерн «один тестовый класс на один тестируемый» (он также
упоминается в книге Мезароша) – самый простой и употребительный
способ организации тестов. Все тесты для всех методов тестируемого
класса находятся в одном большом тестовом классе. Но при этом для
некоторых методов тестов может оказаться так много, что тестовый
класс станет трудно читать и найти в нем что-нибудь будет проблематично. Иногда для одного метода тестов больше, чем для всех остальных вместе взятых. Кстати, это само по себе можно расценивать как
признак того, что метод делает слишком много.

Совет. Удобочитаемостью тестов не следует пренебрегать. Вы пишете тесты не только для компьютера, который будет их выполнять, но и для человека, который станет их читать. Вопросы удобочитаемости будут рассмотрены
в следующей главе.


Если читатель тестов должен будет тратить на поиск нужного кода
больше времени, чем на его понимание, то по мере увеличения размера кода проблема сопровождения встанет во весь рост. Поэтому, возможно, стоить поискать другой способ организации.

## Один тестовый класс на одну функцию

Альтернатива – создать отдельный тестовый класс для функции
приложения (которая может и совпадать с методом). Этот паттерн
также упомянут в книге Мезароша. Если в тестовом классе так много
методов, что его трудно читать, найдите метод или группу методов,
тесты которых оттесняют все остальные на второй план, и создайте
для них отдельный тестовый класс с именем, соответствующим функции.
Пусть в классе LoginManager имеется метод ChangePassword , который требуется протестировать, но возможных случаев так много,
что вы хотите завести для него отдельный класс. В результате получится два тестовых класса: LoginManagerTests, который содержит
все прочие тесты, и LoginManagerTestsChangePassword, который
содержит только тесты метода ChangePassword.

## Соответствие между тестами и точками входа в единицу работы

Одна из ваших главных целей – не только сделать имена тестов удобочитаемыми и понятными, но легко находить все тестовые методы,
относящиеся к конкретной единице работы. Поэтому имена тестов
должны быть осмысленными. Можно сделать частью имени теста
имя исходного открытого метода.
Можно было бы назвать тест ChangePassword_scenario_
expectedbehavior. Это соглашение обсуждалось в главе (раздел 2.3.2). Бывает так, что в продуктовом коде нежелательно использовать приемы внедрения, рассмотренные в предыдущих главах,
например выделение интерфейсов или переопределение виртуальных
методов. Это случается, когда речь идет о сквозной функциональности (cross-cutting concerns).

## Внедрение сквозной функциональности

Если использовать вышеупомянутые приемы в отношении сквозной
функциональности , например управления временем, обработки исключений или протоколирования, то может получиться код, неудобный для чтения и сопровождения.
Проблема в том, что если сквозные функции, например из класса
DateTime, вообще используются в приложении, то они встречаются в
таком количестве, что, оформив их все в виде, допускающем внедрение, как детали конструктора Lego, мы получим код, который будет
замечательно просто тестировать, но совершенно невозможно прочитать и понять.
Предположим, что приложению нужно текущее время для планирования или протоколирования, и мы хотим проверить, что приложение действительно помещает в журналы текущее время. В системе
мог бы присутствовать такой код:


```C#
public static class TimeLogger
{
 public static string CreateMessage(string info)
 {
 return DateTime.Now.ToShortDateString() + “ “ + info;
 }
}
```
Если бы мы захотели повысить тестопригодность, введя интерфейс ITimeProvider , то его пришлось бы использовать всюду,
где встречается DateTime. Это займет очень много времени, а ведь
существуют и более простые подходы.
В примере со временем я предпочел бы создать специальный класс
SystemTime и использовать его всюду в продуктовом коде вместо
встроенного класса DateTime.
Этот класс и переработанный под него продуктовый код показаны
в следующем листинге.

Листинг 7.1. Использование класса SystemTime


```C#
public static class TimeLogger
{
 public static string CreateMessage(string info)
 {
 return SystemTime.Now.ToShortDateString() + “ “ + info;
 }
}
public class SystemTime
{
 private static DateTime _date;
 public static void Set(DateTime custom)
 { _date = custom; }
 public static void Reset()
 { _date=DateTime.MinValue; }
 public static DateTime Now
 {
 get
 {
 if (_date != DateTime.MinValue)
 {
 return _date;
 }
 return DateTime.Now;
 }
 }
}
```

Нехитрый трюк состоит в том, что в классе SystemTime имеются
специальные функции, позволяющие изменять текущее время во
всей системе. Поэтому всюду, где используется этот класс, будут видны те дата и время, которые мы установили.

В результате мы получаем прекрасный способ проверить, что в
продуктовом коде действительно используется текущее время. Он
показан в листинге ниже.

Листинг 7.2. Тест с использованием SystemTime

```C#
[TestFixture]
public class TimeLoggerTests
{
 [Test]
 public void SettingSystemTime_Always_ChangesTime()
 {
 SystemTime.Set(new DateTime(2000,1,1));
 string output = TimeLogger.CreateMessage(“a”);
 StringAssert.Contains(“01.01.2000”, output);
 }
 [TearDown]
 public void afterEachTest()
 {
 SystemTime.Reset();
 }
}
```

Дополнительное преимущество в том, что не требуется внедрять
в приложение миллион интерфейсов. А цена за это невысока – простенький метод с атрибутом [TearDown] в тестовом классе, который
гарантирует, что ни один тест не изменит время, видимое другим тестам.
Однако следует учитывать, что выходная строка зависит от текущей культуры, действующей в системе (например, en-US или
ru-RU). В таком случае можно также снабдить тест атрибутом
CultureInfoAttribute (в случае NUnit), чтобы он работал в контексте конкретной культуры.
Такой способ внешнего абстрагирования сквозной функциональности позволяет создавать в продуктовом коде одну крупную точку
подделывания вместо множества мелких. Но это разумно только для
таких вещей, которые пронизывают систему насквозь. Если распространить эту практику и на все остальное тоже, то получится код, который очень трудно читать, – а именно этого мы и хотели избежать.
Видя этот пример, многие разработчики задают мне вопрос: «Как
заставить всех пользоваться этим классом?». Я отвечаю, что во время анализа кода я слежу за тем, чтобы никто не использовал класс
DateTime напрямую. Я стараюсь не слишком полагаться на инструменты, потому что считаю, что по-настоящему чему-то научиться
можно, лишь когда два (или больше) человека садятся рядом, чтобы
видеть и слышать друг друга и по очереди работать за одной клавиатурой, обсуждая код. Если же речь идет об уже существующем проекте, который мы хотим перевести на использование SystemTime, то я
просто воспользуюсь функцией «поиск в файлах», найду все вхождения DateTime и, если возможно, заменю их. Имя SystemTime выбрано
так, чтобы упростить поиск и замену.
Далее мы обсудим разработку API тестов приложения.


## Разработка API тестов приложения

Начав писать тесты, вы рано или поздно придете к необходимости
подвергать их рефакторингу, создавать служебные методы и классы
и многие другие конструкции (как в тестовых проектах, так и в тестируемом коде) исключительно ради тестопригодности или удобства
чтения и сопровождения тестов.
Вот перечень того, что можно сделать:

- реализовать наследование тестовых классов для различных
целей, в том числе повторного использования;
- написать служебные классы и методы;
- оповестить о предлагаемом API других разработчиков.

Рассмотрим все по порядку

## Наследование тестовых классов

Один из самых сильных аргументов в пользу объектно-ориентированного программирования – возможность повторно использовать
уже имеющуюся функциональность, а не изобретать ее снова и снова в других классах. В книге «The Pragmatic Programmer»2
 (AddisonWesley Professional, 1999) Энди Хант и Дэйв Томас назвали это принципом DRY («don’t repeat yourself» – не повторяйся). Поскольку
автономные тесты, которые мы пишем в .NET и в большинстве объектно-ориентированных языков тоже опираются на объектно-ориентированную парадигму, то не преступление использовать наследование и в самих тестах. На самом деле, я даже всячески рекомендую так поступать, если нет основательных контрдоводов. Реализация базового класса поможет преодолеть типичные проблемы при написании
тестов за счет:

- повторного использования служебных и фабричных методов;
- прогона одного и того же набора тестов для разных классов
(мы рассмотрим этот момент подробнее);
- использования общего кода подготовки и очистки (полезно
также для интеграционного тестирования);
- задания направления тестирования для программистов, которые унаследуют вашему базовому классу.

Я познакомлю вас с тремя паттернами на основе наследования тестовых классов, каждый из которых опирается на предыдущий. Я также объясню, когда использовать тот или иной паттерн, и расскажу об
их плюсах и минусах.

Вот эти три основных паттерна:
- абстрактный тестовый инфраструктурный класс;
- шаблонный тестовый класс;
- абстрактный тестовый управляющий класс.

Мы также рассмотрим следующие приемы рефакторинга, полезные в случае применения вышеупомянутых паттернов:

- создание иерархии классов;
- использование универсальных типов.

## Паттерн абстрактный тестовый инфраструктурный класс

Этот паттерн подразумевает создание абстрактного тестового класса, который содержит необходимую инфраструктуру, общую для производных от него классов. Использовать такой класс можно в самых
разных ситуациях: от общего кода подготовки и очистки до специальных утверждений, которые высказываются в нескольких тестовых
классах.
Мы рассмотрим пример повторного использования метода подготовки в двух тестовых классах. Постановка задачи такова: во всех
тестах необходимо переопределить подразумеваемую по умолчанию
реализацию класса ведения журнала, так чтобы журнал записывался
не в файл, а в память (то есть во всех тестах необходимо разорвать
зависимость от настоящего журнала).
Интересующие нас классы перечислены ниже

- Класс и метод LogAnalyzer – это тот класс и метод, который
требуется протестировать.
- Класс LoggingFacility – класс, где находится реализация регистратора, которую требуется переопределить в тестах
- Класс Con%gurationManager – еще один пользователь класса
LoggingFacility, который мы будем тестировать позже.
- Класс и метод LogAnalyzerTests – тестовый класс и метод,
которые нам предстоит написать сначала
- Класс Con%gurationManagerTests – класс с тестами Con%gurationManager.


Листинг 7.3. Пример игнорирования принципа DRY в тестовых классах

```C#

// $ LoggingFacility
public class LogAnalyzer
{
 public void Analyze(string %leName)
 {
 if (%leName.Length < 8)
 {
 LoggingFacility.Log(“
: “ + %leName);
 }
 //

 }
}
// LoggingFacility
public class Con%gurationManager
{
 public bool IsCon%gured(string con%gName)
 {
 LoggingFacility.Log(“ “ + con%gName);
 return result;
 }
}
public static class LoggingFacility
{
 public static void Log(string text)
 {
 logger.Log(text);
 }
 private static ILogger logger;
 public static ILogger Logger
 {
 get { return logger; }

set { logger = value; }
 }
}
[TestFixture]
public class LogAnalyzerTests
{
 [Test]
 public void Analyze_EmptyFile_ThrowsException()
 {
 LogAnalyzer la = new LogAnalyzer();
 la.Analyze(“myempty%le.txt”);
 // 

 }
 [TearDown]
 public void teardown()
 {
 // 
 LoggingFacility.Logger = null;
 }
}
[TestFixture]
public class Con%gurationManagerTests
{
 [Test]
 public void Analyze_EmptyFile_ThrowsException()
 {
 Con%gurationManager cm = new Con%gurationManager();
 bool con%gured = cm.IsCon%gured(“something”);
 //


 }
 [TearDown]
 public void teardown()
 {
 // 
 LoggingFacility.Logger = null;
 }
}


```

Класс LoggingFacility, скорее всего, будет использоваться во
многих классах. Он спроектирован так, чтобы использующий его код
можно было протестировать, подменив реализацию регистратора путем установки статического свойства.
Имеются два класса, в которых используется LoggingFacility:
LogAnalyzer и Con%gurationManager , и мы бы хотели протестировать оба.

Один из способов улучшить этот код – выделить служебный метод,
чтобы устранить повторы в двух тестовых классах. Оба они подделывают подразумеваемую по умолчанию реализацию регистратора. Мы
можем включить служебный метод в базовый тестовый класс и вызывать его из производных.
Мы не хотим включать метод [SetUp] в базовый класс, потому
что тогда производные стали бы менее понятными. Вместо этого мы
напишем служебный метод FakeTheLogger(). Полный код тестовых
классов приведен ниже.

Листинг 7.4. Код после рефакторинга

```C#
[TestFixture]
public class BaseTestsClass
{
 public ILogger FakeTheLogger()
 {
 LoggingFacility.Logger = Substitute.For<ILogger>();
 return LoggingFacility.Logger;
 }
 [TearDown]
 public void teardown()
 {
 //
 LoggingFacility.Logger = null;
 }
}
[TestFixture]
public class Con%gurationManagerTests:BaseTestsClass
{
 [Test]
 public void Analyze_EmptyFile_ThrowsException()
 {
 FakeTheLogger();
 Con%gurationManager cm = new Con%gurationManager();
 bool con%gured = cm.IsCon%gured(“something”);
 //


 }
}
[TestFixture]
public class LogAnalyzerTests : BaseTestsClass
{
 [Test]
 public void Analyze_EmptyFile_ThrowsException()

{
 FakeTheLogger();
 LogAnalyzer la = new LogAnalyzer();
 la.Analyze(“myempty%le.txt”);
 // 

 }
}
```
Если бы мы включили в базовый класс метод с атрибутом Setup, то
он автоматически вызывался бы перед каждым тестом в любом производном классе. Но тогда читателю производного класса было бы
трудно понять, что происходит на стадии подготовки. Ему пришлось
бы искать метод подготовки в базовом классе, чтобы понять, что производные классы получают по умолчанию. Поскольку при таком подходе ухудшается удобочитаемость тестов, то мы решили остановиться на более явном служебном методе.
Удобочитаемость ухудшается и потому, что коллеги, пользующиеся
базовым классом, почти не имеют документации о его API. Поэтому я
рекомендую применять эту технику настолько редко, насколько возможно, но не реже. Точнее, у меня никогда не было достаточных оснований для использования нескольких базовых классов. Мне всегда
удавалось добиться повышения удобочитаемости с помощью одного
базового класса, путь даже сопровождение становилось чуть менее
удобным. Еще хочу сказать – никогда не используйте в тестах более
одного уровня наследования. Эта мешанина станет неудобочитаемой
быстрее, чем вы успеете произнести «почему сборка не работает?».
Обратимся к более интересному применению наследования для
решения типичной проблемы.

## Шаблонный тестовый класс

Допустим, требуется, чтобы люди, которые разрабатывают определенного вида классы, никогда не забывали создавать для них специальные наборы автономных тестов. Например, речь может идти о коде
для работы с сетью, обеспечения безопасности, работы с базой данных
или просто старого доброго синтаксического разбора. Идея в том, что
для такого класса в тестируемом коде заведомо должны существовать
некоторые тесты, потому что API этого класса предоставляет заранее
известный набор услуг.
Шаблонный тестовый класс – это абстрактный класс, содержащий
абстрактные тестовые методы, которые должны быть реализованы в
производных классах. Движущая сила этого паттерна состоит в том, чтобы заставить производные классы реализовать определенные
тесты.
Подходящими кандидатами для этого паттерна являются классы с
интерфейсами. Я обычно пользуюсь им, когда имеется расширяющаяся иерархия классов, и в каждом новом производном классе реализуются примерно одни и те же идеи.
Можно считать, что интерфейс – это контракт о поведении, то есть
от всех производных классов ожидается одно и то же поведение, хотя
его конкретные формы могут быть разными. Примером контракта о
поведении может служить набор синтаксических анализаторов, каждый из которых реализует методы разбора, которые работают одинаково, но применяются к разным входным типам. Разработчики часто
забывают или просто не хотят писать все тесты, необходимые для
каждого частного случая. Наличие класса, базового для всех классов
с одним и тем же интерфейсом, поможет создать базовый тестовый
контракт, который все разработчики будут обязаны реализовать в
производных тестовых классах.

![наследование1](./images/наследование1png.png)
Типичная иерархия наследования, подлежащая
тестированию, состоит из абстрактного базового класса
и наследующих ему классов

Рассмотрим реальную ситуацию. Допустим, что требуется протестировать объектную модель, показанную на рис. 7.3.
BaseStringParser – абстрактный класс, которому наследуют другие
классы, реализующие некоторую функциональность для строк с разным типом содержимого. Из любой строки (XML-код, строки журнала IIS, стандартные строки) можно получить какую-то информацию о
версии (метаданные). Эти сведения можно извлечь из заголовка (первые несколько строчек строки) и проверить, отвечает ли заголовок
целям приложения. Классы XMLStringParser , IISLogStringParser
и StandardStringParser наследуют базовому классу и реализуют
его методы, сообразуясь со структурой конкретных строк.
Чтобы протестировать такую иерархию, нужно первым делом
написать набор тестов для одного из производных классов (в предположении, что в абстрактном классе нет никакой логики). Затем
аналогичные тесты придется написать для других классов с такой же
функциональностью.
В следующем листинге приведены тесты для класса
StandardStringParser. С них мы начнем, прежде чем переработать
тестовые классы в соответствии с паттерном шаблонного базового
класса.

Листинг 7.5. Набросок тестового класса для StandardStringParser

```C#

[TestFixture]
public class StandardStringParserTests
{
 private StandardStringParser GetParser(string input)
 {
 return new StandardStringParser(input);
 }
 [Test]
 public void GetStringVersionFromHeader_SingleDigit_Found()
 {
 string input = “header;version=1;\n”;
 StandardStringParser parser = GetParser(input
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(“1”,versionFromHeader);
 }
 [Test]
 public void GetStringVersionFromHeader_WithMinorVersion_Found()
 {
 string input = “header;version=1.1;\n”;
 StandardStringParser parser = GetParser(input);
 //

 }
 [Test]

public void GetStringVersionFromHeader_WithRevision_Found()
 {
 string input = “header;version=1.1.1;\n”;
 StandardStringParser parser = GetParser(input);
 // 

 }
}


```

Обратите внимание, как вспомогательный метод GetParser() 1
позволил абстрагировать 2 операцию создания анализатора, присутствующую во всех тестах. Мы пользуемся этим вспомогательным
методом, а не методом подготовки, потому что конструктору следует
передать разбираемую строку, поскольку каждый тест создает анализатор для тестирования определенных входных данных.
В тестах для других классов из этой иерархии мы захотим повторить те же проверки, что и для данного конкретного класса. У всех остальных анализаторов точно такое же внешнее поведение: получить
из заголовка номер версии и проверить, что заголовок корректен. Делают они это по-разному, но семантика не меняется. Это означает, что
для любого класса, производного от BaseStringParser, необходимо
будет написать одни и те же тесты, изменится только тип тестируемого класса.
Но начнем с начала: посмотрим, как легко продиктовать производным тестовым классам, какие тесты необходимы. В следующем листинге показан простой пример такого подхода (интерфейс
IStringParser имеется в исходном коде к этой книге на GitHub).

Листинг 7.6. Шаблонный тестовый класс для тестирования анализаторов
строк


```C#
[TestFixture]
public abstract class TemplateStringParserTests
{
 public abstract
 void TestGetStringVersionFromHeader_SingleDigit_Found();
 public abstract
 void TestGetStringVersionFromHeader_WithMinorVersion_Found();
 public abstract
 void TestGetStringVersionFromHeader_WithRevision_Found();
}
[TestFixture]
public class XmlStringParserTests : TemplateStringParserTests
{

  protected IStringParser GetParser(string input)
 {
 return new XMLStringParser(input);
 }
 [Test]
 public override
 void TestGetStringVersionFromHeader_SingleDigit_Found()
 {
 IStringParser parser = GetParser(“<Header>1</Header>”);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(“1”,versionFromHeader);
 }
 [Test]
 public override
 void TestGetStringVersionFromHeader_WithMinorVersion_Found()
 {
 IStringParser parser = GetParser(“<Header>1.1</Header>”);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(“1.1”,versionFromHeader);
 }
 [Test]
 public override
 void TestGetStringVersionFromHeader_WithRevision_Found()
 {
 IStringParser parser = GetParser(“<Header>1.1.1</Header>”);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(“1.1.1”,versionFromHeader);
 }
}

```

Этот код наглядно представлен на рис. 7.4, где мы видим три производных класса. Отметим, что GetParser() – не унаследованный
метод, в производных классах его можно назвать как угодно.
Меня эта техника выручала во многих ситуациях – и в роли разработчика, и в роли архитектора. Как архитектор, я предлагал разработчикам список наиболее существенных базовых классов и указывал, какие тесты они должны написать. В такой ситуации важно
присваивать тестам понятные имена. Я начинаю имена абстрактных
методов базового класса словом Test, чтобы тем, кто переопределяет их в производных классах, было проще искать, что именно нужно
переопределить.

![pattern1](./images/pattern1.png)

Паттерн шаблонного базового класса гарантирует,
что разработчики не забудут о важных тестах. Базовый класс
содержит абстрактные тестовые методы, которые должны быть
реализованы в производных классах

Но нельзя ли поручить базовому классу побольше работы?

## Паттерн абстрактного управляющего тестового класса, в котором нужно «заполнить недостающее»

 Паттерн абстрактного управляющего тестового класса (я называю
его «заполни недостающее») является развитием изложенной выше
идеи. Только теперь логика тестов реализуется в самом базовом классе, но содержит абстрактные методы-точки подключения, которые
должны быть реализованы в производных классах.
Важно, чтобы тесты относились не к одному конкретному типу
тестируемого класса, а были написаны в соответствии с интерфейсом
или базовым классом в продуктовом коде.
Ниже приведен пример такого базового класса.

Листинг 7.7. Базовый тестовый класс «заполни недостающее»

```C#
public abstract class FillInTheBlanksStringParserTests
{
 protected abstract IStringParser GetParser(string input);

 protected abstract string HeaderVersion_SingleDigit { get; }
 protected abstract string HeaderVersion_WithMinorVersion {get;}
 protected abstract string HeaderVersion_WithRevision { get; }
 public const string EXPECTED_SINGLE_DIGIT = “1”;
 public const string EXPECTED_WITH_REVISION = “1.1.1”;
 public const string EXPECTED_WITH_MINORVERSION = “1.1”;
 [Test]
 public void GetStringVersionFromHeader_SingleDigit_Found()
 {
 string input = HeaderVersion_SingleDigit;
 IStringParser parser = GetParser(input);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(EXPECTED_SINGLE_DIGIT,versionFromHeader);
 }
 [Test]
 public void GetStringVersionFromHeader_WithMinorVersion_Found()
 {
 string input = HeaderVersion_WithMinorVersion;
 IStringParser parser = GetParser(input);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(EXPECTED_WITH_MINORVERSION,versionFromHeader);
 }
 [Test]
 public void GetStringVersionFromHeader_WithRevision_Found()
 {
 string input = HeaderVersion_WithRevision;
 IStringParser parser = GetParser(input);
 string versionFromHeader = parser.GetStringVersionFromHeader();
 Assert.AreEqual(EXPECTED_WITH_REVISION,versionFromHeader);
 }
}
[TestFixture]
public class StandardStringParserTests : FillInTheBlanksStringParserTests
{
 protected override string HeaderVersion_SingleDigit
 {
 get {
 return string.Format(“header\tversion={0}\t\n”,
 EXPECTED_SINGLE_DIGIT);
 }
 }

protected override string HeaderVersion_WithMinorVersion
 {
 get {
 return string.Format(“header\tversion={0}\t\n”,
 EXPECTED_WITH_MINORVERSION);
 }
 }
 protected override string HeaderVersion_WithRevision
 {
 get {
 return string.Format(“header\tversion={0}\t\n”,
 EXPECTED_WITH_REVISION);
 }
 }
 protected override IStringParser GetParser(string input)
 {
 return new StandardStringParser(input);
 }
}

```

В этом листинге в производных классах нет тестов. Они унаследованы. Но при необходимости можно было бы добавить в производные классы дополнительные тесты. На рис. 7.5 показана получившаяся цепочка наследования.
Как следует модифицировать существующий код, чтобы можно было
воспользоваться этим паттерном? Об этом в следующем разделе.

## Преобразование тестового класса в иерархию тестовых классов

Большинство разработчиков вначале не учитывают эти иерархии
наследования, а пишут тесты обычным способом, как показано в
листинге 7.7. Преобразовать уже написанные тесты в базовый класс
сравнительно просто, особенно если в IDE имеются средства рефакторинга, как, например, в Eclipse, IntelliJ IDEA или в Visual Studio
(ReSharper от компании JetBrains, JustCode от Telerik или Refactor!
от DevExpress).

Ниже приведен список шагов рефакторинга тестового класса.

1. Рефакторинг: выделить суперкласс.

- создать базовый класс (BaseXXXTests);
- переместить фабричные методы (например, GetParser) в
базовый класс;
- переместить все тесты в базовый класс;
- сделать ожидаемые результаты открытыми полями базового класса;
- перенести тестовые входные данные в методы или свойства,
реализованные в производных классах.

2. Рефакторинг: сделать фабричные методы абстрактными, возвращающими интерфейсы.
3. Рефакторинг: найти в тестовых методах все места, в которых используются явные типы классов, и заменить их интерфейсами
4. В производных классах реализовать абстрактные фабричные
методы, возвращая из них экземпляры явных типов.

Для создания паттернов наследования можно также воспользоваться универсальными типами .NET.

![pattern2](./images/pattern2png.png)

 Реализация иерархии тестовых классов.
Большинство тестов находится в базовом классе,
но в производных могут быть и дополнительные тесты

## Использование универсальных типов .NET для реализации иерархии тестов

В базовом тестовом классе можно использовать универсальные
типы. Тогда в производных классах не придется переопределять фабричный метод порождения экземпляра, достаточно будет объявить
тестируемый тип. В следующем листинге показан вариант универсального базового тестового класса и производного от него.

Листинг 7.8. Реализация наследования тестов с применением
универсальных типов .NET

```C#
// 
public abstract class GenericParserTests<T>
 where T:IStringParser
{
 protected abstract string GetInputHeaderSingleDigit();
 protected T GetParser(string input)
 {
 return (T) Activator.CreateInstance(typeof (T), input);
 }
 [Test]
 public void GetStringVersionFromHeader_SingleDigit_Found()
 {
 string input = GetInputHeaderSingleDigit();
 T parser = GetParser(input);
 bool result = parser.HasCorrectHeader();
 Assert.IsFalse(result);
 }
 // 
 //...
}
// 

, 
[TestFixture]
public class StandardParserGenericTests
 :GenericParserTests<StandardStringParser>
{
 protected override string GetInputHeaderSingleDigit()
 {
 return “Header;1”;
 }
}
```

В универсальной реализации иерархии изменилось несколько вещей.

- Фабричный метод GetParser 2 больше не переопределяется. Мы просто создаем объект методом Activator.
CreateInstance, который позволяет создавать объекты, заранее не зная их типа, и передаем входную строку конструктору
наряду с типом 3
- В самих тестах используется не интерфейс IStringParser , а
конкретизация универсального типа 4.
- В объявлении универсального класса имеется часть where,
где объявляется, что тип T должен реализовывать интерфейс
IStringParser 1.
- В производном классе реализован метод, возвращающий конкретные входные данные 5.

Вообще говоря, я не вижу особых преимуществ в использовании
универсальных базовых классов. Возможный выигрыш в производительности для тестов несуществен. Решайте сами, какой вариант вам
больше нравится. Это вопрос вкуса, и ничего больше.
Теперь перейдем к совершенно другой теме: инфраструктуре тестовых проектов.

## Создание служебных классов и методов для тестов

При написании тестов создается много простеньких служебных методов, которые, возможно, будут вынесены в отдельные классы (а, возможно, и не будут). Эти служебные классы могут стать существенной
частью API тестов и даже превратиться в простую объектную модель,
используемую при разработке тестов. Служебные методы можно отнести к следующим категориям:

- фабричные методы для объектов, которые трудно создать или
которые раз за разом создаются во многих тестах;
- методы инициализации системы (например, для установки состояния системы перед тестированием или настройки средств
протоколирования на использование регистраторов-заглушек);
- методы конфигурирования объектов (например, для установки внутреннего состояния объекта, скажем, чтобы сделать объект-заказчик непригодным для какой-то операции);
- методы подготовки или чтения внешних ресурсов, например
баз данных, конфигурационных файлов или тестовых входных файлов (скажем, метод, загружающий текстовый файл со
всеми комбинациями входных данных, передаваемых некоторому методу, и ожидаемых от него результатов). Чаще такие методы встречаются при интеграционном или комплексном тестировании;
- специальные методы утверждения, в которых высказывается
утверждение о состоянии системы, достаточно сложное или
встречающееся многократно (если что-то записывается в системный журнал, то метод может утверждать, что X, Y и Z истинны, а G – нет.)

Служебные методы можно объединить в служебные классы, например:
- служебные классы утверждений, содержащие все специальные методы утверждения;
- классы, содержащие фабричные методы;
- конфигурационные классы (в том числе для конфигурирования баз данных), относящиеся к интеграционному тестированию.

Для платформы .NET существует несколько служебных каркасов с
открытым исходным кодом, предлагающих элегантные способы решения такого рода задач. Один из них – каркас Fluent Assertions – находится по адресу https://github.com/dennisdoomen/FluentAssertions.
Само наличие служебных методов еще не означает, что кто-то будет
ими пользоваться. Я видел немало проектов, в которых разработчики
раз за разом изобретали велосипед, создавая служебные методы,
которые уже были написаны раньше, только никто о них не знал.
Далее мы поговорим о том, как распространить сведения о своем
API.

## Извещение разработчиков об имеющемся API

Важно, чтобы авторы тестов знали о различных API, созданных
по мере разработки приложения и тестов для него. Есть несколько
способов распространить сведения о написанном вами API.

- Посадить за написание тестов двух человек или группы по два
человека (хотя бы ненадолго), из которых один знаком с существующими API и может рассказать другому об их достоинствах.
- Составить короткий документ (не более чем на пару страниц)
или шпаргалку, в которой описывается, какие API существуют
и где их найти. Можно готовить короткие документы по каждой части системы тестирования (например, об API, относящихся к уровню работы с данными) или глобальный документ,
охватывающий все приложение. Если документ длинный,
никто не станет его сопровождать. Один из способов обеспечить актуальность – автоматизировать процедуру генерации
документа:
- договориться о наборе префиксов или суффиксов имен
вспомогательных API;
- написать специальный инструмент, который ищет имена
API и генерирует документ, содержащий их перечень и сведения о местонахождении; альтернативно можно включать
специальные комментарии с директивами, которые инструмент может извлечь;
- включить генерацию документа в состав автоматизированной процедуры сборки.

* Обсуждать изменения API на собраниях команды – одна-две
фразы касательно сути основных изменений и того, где их искать. Тогда команда будет знать, что это важно, а этим никогда
пренебрегать не следует.
* Прорабатывать этот документ со всеми вновь принятыми на
работу на стадии ознакомления.
* Проводить анализ тестов (в дополнение к анализу кода), обращая внимание на стандарты удобочитаемости, удобства сопровождения, правильности и на использование подходящих
API в нужных местах. Подробнее об этой практике см. статью http://5whys.com/blog/step-4-start-doing-code-reviewsseriously.html в моем блоге для руководителей программистских коллективов

Следование хотя бы некоторым из этих советов поможет поддерживать продуктивность команды и создать общий язык, на котором
все пишут тесты.

## Выводы

Подведем итоги тому, что следует вынести из только что прочитанной
главы.

* Каким бы видом тестирования вы ни занимались, автоматизируйте эту деятельность; запускайте автоматизированную
процедуру сборки как можно чаще – днем или ночью – и как
можно чаще проводите непрерывную интеграцию продукта.
* Отделяйте интеграционные тесты от автономных (медленные
тесты от быстрых), чтобы у команды была безопасная зеленая
зона, в которой все тесты должны проходить.
* Классифицируйте тесты по проекту и по типу (автономные
и интеграционные, медленные и быстрые) и разносите их по
разным каталогам, папкам или пространствам имен (или по
всему вместе). Я обычно применяю все три типа разделения.
* Используйте иерархию тестовых классов для применения одного и того же набора тестов к нескольким взаимосвязанным
тестируемым типам, организованным иерархически, или к типам, имеющим общий интерфейс или базовый класс.
* Применяйте вспомогательные и служебные классы вместо иерархий, если организация иерархии делает тесты менее удобочитаемыми, а особенно когда в базовом классе оказывается
общий метод подготовки. Существуют разные точки зрения на
то, когда использовать каждый из этих способов, но обычно
главным аргументом против иерархий служит неудобочитаемость.

Извещайте о написанном вами API других членов команды. В противном случае вы будете просто транжирить время и деньги, потому
что коллеги по незнанию будут изобретать одни и те же API снова и
снова.
