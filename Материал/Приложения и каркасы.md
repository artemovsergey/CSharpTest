# Инструменты и каркасы

Эта книга была бы неполной без обзора некоторых инструментов
и основных приемов написания автономных тестов. В приложении
описываются инструменты, подходящие для самых разных видов тестирования: работы с базами данных, пользовательского интерфейса,
веб-приложений. Одни используются для интеграционного тестирования, другие – и для автономного тоже. Особо я отмечаю те, что, на
мой взгляд, хороши для начинающих.
Инструменты и методики разбиты на следующие категории:

- изолирующие каркасы;
- каркасы тестирования;
  - исполнители тестов;
  - API тестирования;
- вспомогательные средства тестирования;
- DI и IoC-контейнеры;
- тестирование работы с базами данных;
- тестирование веб-приложений;
- тестирование пользовательского интерфейса;
- тестирование многопоточных приложений;
- приемочное тестирование.


## Изолирующие каркасы

Изолирующие каркасы, или каркасы подставных объектов – это
плоть и кровь автономного тестирования в достаточно сложных случаях. Выбирать есть из чего, и это прекрасно:

- Moq
- Rhino Mocks
- Typemock Isolator
- JustMock
- Moles/Microsoft Fakes
- NSubstitute
- FakeItEasy
- Foq

В предыдущем издании этой книги описывались еще два инструмента, которые я удалил, поскольку они устарели:
- NMock
- NUnit.Mocks

Ниже приводятся краткие описания каждого каркаса.

## Moq

Moq – изолирующий каркас с открытым исходным кодом и API,
претендующим на простоту изучения и использования. Это один из
первых API, построенных в стиле подготовка–действие–утверждение (в противоположность модели запись–воспроизведение, применявшейся в более ранних каркасах) и опирающихся на возможности,
появившиеся в .NET 3.5 и 4, в частности лямбда-выражения и методы
расширения. Чтобы им пользоваться, необходимо уверенно владеть
синтаксисом лямбда-выражений. Впрочем, это относится и ко всем
остальным каркасам из списка.
Осваивается каркас легко. Могу лишь придраться к чрезмерному
использованию слова mock в API, что только вносит путаницу. Я хотел бы, по крайней мере, чтобы было проведено различие между созданием заглушек или подставок. А еще лучше, чтобы в обоих случаях
употреблялось слово fake, что устранило бы сам источник путаницы.
О Moq можно прочитать на сайте http://code.google.com/p/moq/ и
установить пакет через NuGet.

## Rhino Mocks

Rhino Mocks – широко используемый открытый каркас для создания
заглушек и подставок. В предыдущем издании я его рекомендовал,
сейчас не рекомендую. Его разработка практически прекращена, к
тому же существуют более легкие, простые и удачно спроектированные каркасы. Если есть возможность, не пользуйтесь им. Автор, Айенде (Ayende), написал в Твиттере, что больше его не поддерживает.

## Typemock Isolator

Typemock Isolator – коммерческий неограниченный (умеет подделывать все, см. главу 6) изолирующий каркас, в котором сделана попытка убрать из лексикона термины заглушки и подставки в пользу более
простого и лаконичного API.
Isolator отличается от других каркасов тем, что позволяет изолировать компоненты от зависимостей, как бы ни была спроектирована
система (хотя при этом поддерживает все функции, имеющиеся в других каркасах). Это делает его идеальным выбором для людей, которые только приступают к автономному тестированию и хотят изучать
вопросы проектирования и тестопригодности постепенно. Поскольку
каркас не заставляет учитывать тестопригодность при проектировании, вы можете сначала научиться правильно писать тесты, а потом
заняться повышением квалификации в части проектирования, а не
смешивать все сразу. Но это и самое дорогое из неограниченных решений, что, правда, окупается удобством работы и возможностью использования для унаследованного кода.
Есть два варианта Typemock Isolator: бесплатная базовая редакция
со всеми недостатками, присущими ограниченному каркасу (возможность подделывания только нестатических виртуальных методов
и т. д.), и неограниченная платная редакция, умеющая подделывать
почти все.

## JustMock

JustMock от компании Telerik – сравнительно новый изолирующий
каркас, явно нацеленный на конкуренцию с Typemock Isolator. API
обоих каркасов похожи по структуре, так что при выполнении простых действий можно сравнительно легко переключаться между
ними. Как и Typemock, JustMock поставляется в двух вариантах: ограниченная бесплатная редакция и неограниченная платная, способная
подделывать почти все.
В API есть небольшие шероховатости, и, насколько я знаю, пока не
поддерживаются рекурсивные подделки – возможность изготовить
подделку, которая возвращает поддельный объект, который возвращает поддельный объект…, не описывая все это явно. Получить продукт можно на странице www.telerik.com/products/mocking.aspx.

## Microsoft Fakes (Moles)

 Проект Microsoft Fakes был запущен в исследовательском центре
Microsoft для ответа на вопрос: «Как мы можем подделывать файловую систему и другие вещи, например SharePoint, не покупая компанию типа Typemock?». В результате появился каркас Moles. Позже он
перерос в Microsoft Fakes и теперь включается в некоторые версии
Visual Studio.
MS Fakes – еще один неограниченный изолирующий каркас, который не имеет API для проверки того, что нечто вызывалось. По существу, он предоставляет средства для создания заглушек. Высказать
утверждение о том, что некоторый объект вызывался, можно, но тестовый код при этом будет совершенно неудобочитаемым.
Как и описанные выше неограниченные каркасы, MS Fakes позволяет создавать поддельные объекты двух типов: вы либо генерируете
неограниченные классы, которые наследуют и переопределяют уже
тестопригодный код, либо используете прокладки (shim). Прокладки не ограничены, а заглушки, сгенерированные классы, ограничены.
Запутались? Я тоже. Одна из причин, по которым я никому, кроме
особо героических личностей, которым нечего терять, не рекомендую
использовать MS Fakes – чудовищно неудобный API. Все запутанно до невозможности. К тому же, сопровождение тестов, в которых
используются прокладки или заглушки, остается под вопросом. Сгенерированные заглушки необходимо перегенерировать при каждом
изменении тестируемого кода, после чего необходимо изменить тесты. А код, где используются прокладки, очень длинный, его трудно читать, а, значит, и сопровождать. Пусть даже MS Fakes бесплатный и
включен в Visual Studio, но работа с ним обойдется очень дорого, если
выражать цену ее в часах, потраченных разработчиком на попытки
разобраться в ваших тестах и исправить их.
И еще один немаловажный момент: если вы пользуетесь MS Fakes,
то в качестве каркаса тестирования обязаны использовать MSTest.
Никакой другой не подойдет.
Если вам нужен неограниченный каркас для написания тестов, которые будут жить дольше, чем неделя-другая, то берите JustMock или
Typemock Isolator.
Дополнительные сведения о MS Fakes читайте на странице http://
msdn.microsoft.com/en-us/library/hh549175.aspx.

## NSubstitute

NSubstitute – ограниченный изолирующий каркас с открытым исходным кодом. API очень прост для освоения и использования, имеется отличная документация. Еще плюс: сообщения об ошибках очень
подробны. Наряду с FakeItEasy именно этот ограниченный каркас я
бы в первую очередь рекомендовал для нового проекта.
Дополнительные сведения о NSubstitute см. на сайте http://
nsubstitute.github.com/. Пакет устанавливается через NuGet.

## FakeItEasy

У каркаса FakeItEasy не только очень удачное название, но и весьма
симпатичный API. Он и NSubstitute на сегодня мои любимые ограниченные каркасы, но документация у FakeItEasy похуже. Что мне
особенно нравится в API, так это буква A в начале любой операции,
например:

```C#

var foo = A.Fake<IFoo>();
A.CallTo(() => foo.Bar()).MustHaveHappened();

```

## Foq

Каркас Foq появился в ответ на потребность программистов на F#
создавать подделки, удобные для использования из F#. Этот ограниченный изолирующий каркас умеет подделывать абстрактные классы
и интерфейсы. Лично я им не пользовался, т. к. никогда не работал на
F#, но, похоже, в этом сегменте это единственное приемлемое решение. Дополнительные сведения о Foq см. на сайте https://foq.codeplex.
com/. Пакет устанавливается через NuGet.

## Isolator++

Isolator++ — распространяемый компанией Typemock неограниченный изолирующий каркас для C++. Он умеет подделывать статические методы, закрытые методы и многое другое в унаследованном коде
на C++. Продукт коммерческий и, похоже, единственный в этом сегменте, обладающий такими возможностями. Дополнительные сведения см. на странице www.typemock.com/what-is-isolator-pp.

## Каркасы тестирования

Каркасы тестирования предлагают функциональность двух типов:
- исполнители тестов выполняют написанные вами тесты, отображают результаты и позволяют узнать, где имели место ошибки;
- API тестирования включают атрибуты или базовые классы,
которым вы должны унаследовать, а также API для высказывания утверждений.

Рассмотрим по очереди.

Исполнители тестов, работающие внутри Visual Studio:
- исполнитель MS, встроенный в Visual Studio;
- TestDriven.NET;
- ReSharper;
- NUnit;
- DevExpress;
- Typemock Isolator;
- NCrunch;  
- ContinuousTests (Mighty Moose).

API тестирования и утверждений:
- NUnit.Framework;
- Microsoft.VisualStudio.TestPlatform.UnitTestFramework;
- Microsoft.VisualStudio.TestTools.UnitTesting;
- FluentAssertions;
- Shouldly;
- SharpTestEx;
- AutoFixture.

## Непрерывный исполнитель тестов Mighty Moose (он же ContinuousTests)

Когда-то коммерческий, а ныне бесплатный, инструмент, Mighty
Moose предназначен для того, чтобы непрерывно информировать о
тестах и покрытии кода, как и NCrunch.
- Он прогоняет тесты в фоновом потоке.
- Тесты автоматически прогоняются после сохранения и компиляции кода.
- Встроенный алгоритм определяет, какие тесты прогонять в зависимости от того, какой код изменился.

К сожалению, развитие этого инструмента, похоже, прекращено.
Дополнительные сведения см. на сайте http://continuoustests.com.

## Непрерывный исполнитель тестов NCrunch

NCrunch – коммерческий продукт, предназначенный для того, чтобы
непрерывно информировать о тестах и покрытии кода. Появившись
сравнительно недавно, NCrunch завоевал мое сердце (я купил лицензию) благодаря нескольким удобным функциям.

- Он прогоняет тесты в фоновом потоке.
- Тесты запускаются автоматически при изменении кода, даже
сохранять необязательно.
- Зеленые и красные точки слева от тестов и продуктового
кода информируют о том, покрыта ли текущая строка каким-нибудь тестом и проходит в данный момент этот тест
или нет.
- Он очень гибко конфигурируется, иногда это даже раздражает.
Просто запомните: когда в начале работы над простым проектом открывается мастер, жмите Esc, принимая подразумеваемый по умолчанию режим прогона всех тестов.

## Исполнитель тестов Typemock Isolator

Этот исполнитель тестов является частью коммерческого изолирующего каркаса Typemock Isolator. Пытается прогонять тесты и одновременно показывать покрытие
при каждой компиляции. Пока в стадии бета-версии, ведет себя нестабильно. Быть может, когда-нибудь станет более полезным, но сейчас я
его обычно отключаю и пользуюсь API изолирующих каркасов.

## Исполнитель тестов CodeRush

 Этот исполнитель тестов является частью коммерческого продукта
CodeRush – хорошо известной надстройки над Visual Studio.
Как и у ReSharper, у этого инструмента есть ряд достоинств:
- он хорошо интегрирован с редактором кода Visual Studio – показывает против каждого теста отметку, щелкнув по которой
можно этот тест выполнить;
- поддерживает большинство API тестирования, имеющихся
для .NET.
- если вы уже пользуетесь CodeRush, то этого исполнителя будет вполне достаточно.

Как и в случае ReSharper, визуальное представление результатов
тестов может показаться помехой опытным практикам TDD. Дерево
выполняющихся тестов и показ по умолчанию всех результатов, даже
прошедших тестов, – пустая трата времени, когда работа над TDD в
самом разгаре. Но некоторым нравится. Дело вкуса.

## Исполнитель тестов ReSharper

Этот исполнитель тестов является частью коммерческого продукта
ReSharper – хорошо известной надстройки над Visual Studio.

У этого исполнителя есть ряд достоинств:
- он хорошо интегрирован с редактором кода Visual Studio – показывает против каждого теста отметку, щелкнув по которой
можно этот тест выполнить;
- поддерживает большинство API тестирования, имеющихся
для .NET.
- если вы уже пользуетесь ReSharper, то этого исполнителя будет вполне достаточно.

Недостатком я считаю излишне навязчивое визуальное представление результатов тестов. Дерево выполняющихся тестов очень
красивое и расцвеченное. Но эта красота и показ по умолчанию всех
результатов, даже прошедших тестов, только отвлекает, когда работа
над TDD в самом разгаре. Но некоторым нравится. Дело вкуса.

## Исполнитель TestDriven.NET

Это коммерческий исполнитель тестов (бесплатный для личного использования). Пока я не начал пользоваться NCrunch, он был моим
любимым. И его есть за что любить.
- Он умеет прогонять тесты для большинства, если не всех, каркасов тестирования, существующих на платформе .NET, в том
числе NUnit, MSTest, xUnit.net, а также для некоторых каркасов на основе BDD.
- Пакет совсем небольшой с минималистским интерфейсом. Вывод результатов прост: они появляются в окне вывода Visual
Studio плюс текст в нижних боковых панелях Visual Studio.
- Он очень быстрый, один из самых быстрых исполнителей тестов.
- У него есть уникальная функция: можно щелкнуть правой
кнопкой мыши по любому участку кода (не только по тесту)
и выбрать из контекстного меню пункт Test with → Debugger
(Тестировать с помощью → Отладчик). После этого вы сможете пошагово отлаживать любой код (даже продуктовый, даже
если для него нет тестов). Под капотом TD.NET вызывает метод, в котором вы находитесь, с помощью механизма отражения и, если ему нужны параметры, подставляет значения по
умолчанию. Это экономит уйму времени при работе с унаследованным кодом.

Рекомендуется назначить комбинацию клавиш команде TD.NET
ReRunTests в Visual Studio, чтобы, применяя методику TDD, не терять концентрации.

## Исполнитель NUnit GUI

Исполнитель NUnit GUI бесплатный и распространяется с открытым
исходным кодом. Он не интегрирован с Visual Studio, так что запускать
его придется с рабочего стола. Поэтому им почти никто не пользуется,
если имеются перечисленные здесь интегрированные альтернативы.
Интерфейс плохо продуман, содержит много шероховатостей, так что
не рекомендую.

## Исполнитель MSTest

Исполнитель MSTest встроен во все версии Visual Studio. В платных
версиях в нем имеется механизм надстроек, который позволяет добавлять поддержку прогона тестов с другими API, например NUnit
или xUnit.net, с помощью специальных адаптеров, устанавливаемых
как расширения Visual Studio.
Очком в пользу этого исполнителя является интеграция с комплектом инструментов Visual Studio Team System и хорошие готовые
средства отчетности, покрытия и автоматизации сборки. Если в вашей компании для автоматизации сборки используется Team System,
попробуйте MSTest в качестве исполнителя тестов в ночных и НИсборках, так как его возможности интеграции, в частности средства
формирования отчетов, очень неплохи.
Из недостатков MSTest отмечу низкую производительность и наличие зависимостей.

- Зависимости. Для прогона тестов с помощью mstest.exe на машине сборке должна быть установлена Visual Studio. Кому-то
это удобно, особенно если вы компилируете код там же, где
прогоняете тесты. Но если вы хотите прогонять тесты в относительно чистом окружении, в уже откомпилированном виде,
то это перебор, и уж совсем проблематично, если тесты требуется прогонять в окружении, где Visual Studio быть не должно.
- Низкое быстродействие. В MSTest многое происходит под
капотом до и после выполнения каждого теста: копирование
файлов, запуск внешних процессов, профилирование и прочее. В результате по ощущениям MSTest воспринимается как
самый медленный исполнитель из всех, с которыми мне доводилось работать.

## Pex

Pex (сокращение от «program exploration» – исследование программы) – интеллектуальный помощник программиста. Из параметризованного автономного теста он автоматически порождает традиционный комплект автономных тестов с высоким покрытием кода. Кроме
того, он подсказывает программисту, как исправить ошибки.
Pex позволяет создать специальные тесты с параметрами, пометив
их особыми атрибутами. Движок Pex генерирует новые тесты, которые затем можно прогонять как часть комплекта. Он очень хорош,
когда нужно найти граничные условия и редкие случаи, которые
программа обрабатывает неправильно. Pex следует использовать в
дополнение к обычному каркасу тестирования, например NUnit или
MbUnit.
Скачать Pex можно со страницы http://research.microsoft.com/
projects/pex/.

## API тестирования

Далее мы рассмотрим инструменты, предлагающие высокоуровневые
абстракции и обертки для базовых каркасов автономного тестирования.

## MSTest API – каркас автономного тестирования от Microsoft

Поставляется в составе редакции Visual Studio .NET Professional или
старше. Включает ряд средств, аналогичных NUnit.
Но из-за некоторых проблем MSTest не столь хорош для автономного тестирования, как NUnit или xUnit.net:
- расширяемость;
- отсутствие Assert.Throws.

## Расширяемость

Серьезная проблема этого каркаса – то, что расширить его не так
просто, как другие каркасы тестирования. Хотя в прошлом в Сети велись дискуссии на тему того, как сделать MSTest более расширяемым
за счет специальных атрибутов, похоже разработчики Visual Studio
отказались от мысли победить в конкуренции с NUnit и другими
продуктами.
Вместо этого в VS 2012 включен механизм надстроек, который позволяет назначить NUnit или еще что-нибудь каркасом тестирования
по умолчанию, и тогда MSTest будет прогонять тесты, написанные
для NUnit. Уже существуют адаптеры для NUnit и xUnit.net, если вас
устраивает исполнитель MSTest с другими каркасами. К сожалению,
в бесплатной редакции Visual Studio Express этот механизм отсутствует, что заставляет использовать не столь качественный MSTest.
(Кстати говоря, почему Microsoft вынуждает нас платить за Visual
Studio, чтобы мы разрабатывали код, который сделает господство
платформы MS еще более всеобъемлющим?)

## Отсутствие Assert.Throws

Тут все просто. В MSTest имеется атрибут ExpectedException,
но нет метода Assert.Throws, который позволил бы проверить, что
некоторая строка возбуждает исключение. Спустя шесть лет после
появления на рынке и четыре года после того, как это было сделано
в большинстве других каркасов, разработчики MSTest так и не
удосужились добавить реализацию, насчитывающую буквально 10
строчек кода. Это заставляет меня задуматься, а интересны ли им
вообще автономные тесты.

## MSTest для приложений Metro (магазин Windows)

MSTest для приложений Metro – это API для создания приложений,
выставляемых в магазине Windows. Выглядит он как MSTest, но, похоже, отношение к автономным тестам в нем изменилось в лучшую
сторону. Например, появился метод Assert.ThrowsException().
Создается впечатление, что при написании приложений для магазина Windows мы вынуждены использовать этот каркас, но решение существует, если воспользоваться связанными проектами.
Дополнительные сведения см. на странице http://stackoverflow.com/
questions/12924579/testing-a-windows-8-store-app-with-nunit.

## NUnit API

В настоящее время NUnit – стандарт API тестирования де факто для
разработчиков автономных тестов на платформе .NET. Он распространяется с открытым исходным кодом и используется практически
всеми. В главе 2 я рассказывал о нем подробно. NUnit легко расширяется и имеет обширное сообщество пользователей и форумы. Я рекомендую его всем, кто начинает заниматься автономным тестированием в .NET. Я пользуюсь им и по сей день.
Скачать NUnit можно с сайта www.Nunit.org

## xUnit.net

xUnit.net – каркас тестирования с открытым исходным кодом, разработанный в сотрудничестве с одним из авторов NUnit, Джимом
Ньюкирком (Jim Newkirk). Это элегантный минималистский каркас,
который стремится вернуться к основам, реализуя не больше, а меньше функций, чем в других каркасах. К тому же, названия атрибутов
в нем другие.
Что в этом такого радикально отличающегося? Ну, во-первых, нет
методов подготовки и очистки. В тестовом классе должен быть реализован конструктор и метод Dispose. Другое существенное отличие – простота расширения.
Поскольку xUnit.net так сильно отличается от других каркасов,
требуется время, чтобы привыкнуть к нему после работы, скажем, с
NUnit или MbUnit. Если вы никогда прежде не работали ни с какими
каркасами, то освоить и использовать xUnit.net будет легко, и он достаточно стабилен для применения в реальном проекте.
Получить дополнительную информацию и скачать xUnit.net можно на сайте www.codeplex.com/xunit.

## Вспомогательный API Fluent Assertions

Вспомогательный API Fluent Assertions – новая разновидность API
тестирования. Это элегантная библиотека, предназначенная для одной-единственной цели: позволить высказывать утверждения о чем
угодно безотносительно к используемому API тестирования. Например, с ее помощью можно получить функциональность типа Assert.
Throws() в MSTest.
Дополнительные сведения см. на сайте http://fluentassertions.
codeplex.com/

## Вспомогательный API Shouldly

Этот API очень похож на Fluent Assertions, но меньше. Он также
предназначен для единственной цели: высказывать утверждения о чем угодно безотносительно к используемому API тестирования. Дополнительные сведения см. на сайте http://shouldly.github.com.

## Вспомогательный API SharpTestsEx

Как и Fluent Assertions, вспомогательный API SharpTestsEx предназначен для того, чтобы высказывать утверждения о чем угодно безотносительно к используемому API тестирования. Дополнительные
сведения см. на сайте http://sharptestex.codeplex.com.

## Вспомогательный API AutoFixture

AutoFixture – не API для утверждений. Он предназначен для того,
чтобы упростить создание тестируемых объектов, специфика которых вам не интересна. Например, вам нужно какое-то число или строка. Считайте AutoFixture умной фабрикой, которая умеет внедрять
объекты и входные данные в ваш тест.
Я знакомился с этим продуктом и больше всего мне понравилось
его умение создавать экземпляр тестируемого класса, не зная сигнатуры его конструктора, т. к. это делает мои тесты более пригодными к
длительному сопровождению. Но все же одного этого недостаточно,
чтобы я начал его всерьез использовать, потому что то же самое я могу
сделать, написав небольшой фабричный метод.
Кроме того, меня немного пугает тот факт, что он внедряет в мои
тесты случайные значения, потому что получается, что при каждом
прогоне я выполняю новый тест. Это также усложняет утверждения,
т. к. мне приходится вычислять ожидаемое значение, исходя из случайных параметров внедренного объекта, а это может окончиться
дублированием логики продуктового кода в тестах.
Дополнительные сведения можно найти на странице https://github.
com/AutoFixture/AutoFixture.

##  IoC-контейнеры

IoC-контейнеры можно использовать для улучшения архитектурных
свойств объектно-ориентированной системы за счет сокращения ручных технических издержек, связанных с применением методов добротного проектирования (использование параметров конструктора,
управление временем жизни объектов и т. д.).
Контейнеры ослабляют связанность классов и их зависимостей,
улучшают тестопригодность структуры классов и обеспечивают общие механизмы повышения гибкости. При благоразумном использовании контейнеры могут существенно расширить возможности повторного использования кода благодаря устранению прямых связей
между классами и механизмами конфигурирования (например, за
счет использования интерфейсов).
На платформе .NET в контейнерах нет недостатка. Они очень
разнообразны и представляют немалый интерес для исследователя.
Если вас волнует производительность, то на странице http://www.
palmmedia.de/Blog/2011/8/30/ioc-container-benchmark-performancecomparison имеются результаты сравнения контейнеров. Лично мне
никогда не казалось, что IoC-контейнеры – первопричина проблем с
производительностью, но если бы это было так, то я бы первым делом
заглянул на эту страницу.
Как бы то ни было, контейнеров много, но мы рассмотрим те, которые наиболее часто употребляются в сообществе.
Я отобрал их на основе результатов опроса, который провел в своем блоге в марте 2013 года. Вот как выглядит шестерка лучших:
- Autofac (Auto Factory)
- Ninject
- Castle Windsor
- Microsoft Unity
- StructureMap
- Microsoft Managed Extensibility Framework
Рассмотрим их по очереди.

## Autofac
Autofac одним из первых предложил новый подход к IoC в .NET, хорошо согласующийся с синтаксическими нововведениями в C# 3 и 4.
С точки зрения API, принятый в нем метод можно назвать минималистским. Его API радикально отличается от других каркасов, к
нему нужно привыкнуть. Кроме того, для работы требуется .NET 3.5
и свободное владение синтаксисом лямбда-выражений. Рассказать об
Autofac в двух словах довольно трудно, зайдите на сайт и посмотрите,
на что он похож. Я рекомендую этот каркас тем, кто уже имеет опыт с
другими DI-каркасами.
Домашняя страница Autofac находится по адресу http://code.
google.com/p/autofac/.

## Ninject

У Ninject простой синтаксис, работать с ним удобно. Больше особо
сказать нечего, кроме того, пожалуй, что я горячо рекомендую познакомиться с ним.
Найти дополнительные сведения о Ninject можно на сайте http://
ninject.org/.

##  Castle Windsor

Castle – большой проект с открытым исходным кодом, охватывающий самые разные территории. Windsor – одна из них, это зрелая и
мощная реализация DI-контейнера.
Castle Windsor содержит большую часть функций, которые могут
потребоваться от контейнера, и еще многое другое, но из-за этого освоить его нелегко.
Дополнительные сведения о контейнере Castle Windsor см. на странице http://docs.castleproject.org/Windsor.MainPage.ashx.

## Microsoft Unity

Unity пришел на территорию DI-контейнеров довольно поздно, но
предлагает простой минималистский подход, легко доступный начинающим. Опытным пользователям может чего-то не хватать, но нет
сомнений, что каркас следует правилу 80–20: он предоставляет 80 %
наиболее востребованных возможностей.
Каркас Unity разработан Microsoft, распространяется с открытым
исходным кодом и хорошо документирован. Рекомендую его в качестве отправной точки для работы с контейнерами.

Домашняя страница Unity находится по адресу www.codeplex.com/
unity.

## StructureMap

StructureMap – контейнер с открытым исходным кодом, написанный
Джереми Д. Миллером (Jeremy D. Miller). Его текучий API пытается
моделировать естественный язык, в нем очень широко используются
универсальные конструкции.
Документации маловато, зато имеются такие интересные возможности, как встроенный контейнер автоподставок (который может автоматически создавать заглушки, запрашиваемые тестом), развитый
механизм управления временем жизни, конфигурирование без XML,
интеграция с ASP.NET и многое другое.
Домашняя страница StructureMap находится по адресу http://
structuremap.net.

## Microsoft Managed Extensibility Framework

Managed Extensibility Framework (MEF) – на самом деле, не контейнер, но попадает в ту же общую категорию поставщиков служб создания экземпляров классов в программе. Он задуман как нечто гораздо
большее, чем простой контейнер; это полноценная модель надстроек
для небольших и крупных приложений. MEF включает облегченный
IoC-контейнер, чтобы можно было без труда внедрять зависимости в
разные места программы с помощью специальных атрибутов. Кривая
обучения MEF довольно крута, и я не рекомендую использовать
его просто в качестве IoC-контейнера. Но если ваше приложение
нуждается в механизмах расширяемости, то MEF заодно может
послужить и DI-контейнером.
Домашняя страница MEF находится по адресу http://mef.codeplex.
com/

## Тестирование работы с базами данных

Как тестировать работу с базами данных – жгучий вопрос для многих
начинающих. Например, следует ли заглушать базу данных в тестах?
В этом я разделе я приведу некоторые рекомендации.
Но прежде несколько слов об интеграционном тестировании с
участием базы данных.

## Использование интеграционных тестов для уровня данных

Как тестировать уровень данных? Следует ли абстрагировать интерфейсы работы с базой данных? Нужно ли использовать настоящую
базу данных?
Я обычно пишу для уровня данных (той части приложения, которая непосредственно обращается к базе данных) интеграционные
тесты, потому что логика работы с данными почти всегда распределена между логикой приложения и самой базой (триггеры, правила
защиты, ссылочная целостность и т. д.). Если вы не можете протестировать логику базы данных в полной изоляции (а я пока не встречал достойного каркаса для этой цели), то единственный способ
проверить ее работу в тестах – подключить логику уровня данных к
настоящей базе.
После совместного тестирования уровня данных и базы данных
в проекте остается мало сюрпризов. Но само тестирование базы сопряжено с проблемами, из которых самая серьезная состоит в том,
что база данных – это состояние, разделяемое многими тестами. Если
один тест вставил в базу строку, то следующий ее увидит.
Поэтому необходим какой-то способ отката сделанных изменений, и, к счастью, в .NET Framework такой способ есть и притом
несложный.

## Использование TransactionScope для отката изменений данных

Класс TransactionScope достаточно развит для обработки очень
сложных транзакций, в том числе вложенных, когда тестируемый код
сам фиксирует локальную транзакцию.
Следующий простой пример показывает, как просто добавить в
тесты механизм отката.

```C#

[TestFixture]
public class TrannsactionScopeTests
{
 private TransactionScope trans = null;
 [SetUp]

  public void SetUp()
 {
 trans = new TransactionScope(TransactionScopeOption.Required);
 }
 [TearDown]
 public void TearDown()
 {
 trans.Dispose();
 }
 [Test]
 public void TestServicedSameTransaction()
 {
 MySimpleClass c = new MySimpleClass();
 long id = c.InsertCategoryStandard(“whatever”);
 long id2 = c.InsertCategoryStandard(“whatever”);
 Console.WriteLine(“Got id of “ + id);
 Console.WriteLine(“Got id of “ + id2);
 Assert.AreNotEqual(id, id2);
 }
}

```

В методе подготовки мы создаем область видимости транзакции, а
в методе очистки уничтожаем ее.
Поскольку на уровне тестового класса транзакция не фиксируется,
то все изменения в базе откатываются, потому что метод Dispose()
инициирует откат, если до этого не вызывался метод Commit().
Некоторые считают разумным другой подход – прогонять тесты,
подключаясь к базе данных в памяти. Я испытываю смешанные чувства по этому поводу. С одной стороны, такие тесты ближе к реальности, потому что тестируется логика базы данных. С другой стороны,
если приложение работает с совершенно другой СУБД, имеющей
собственные механизмы, то велик шанс, что какие-то вещи в тестах
будут работать одним способом, а в производственной системе — другим. Я предпочитаю то, что максимально близко к реальной среде.
Обычно это означает работу с одной и той же СУБД.
Но если база данных в памяти обладает точно такими же функциями и логикой, то идея может оказаться неплохой.

## Тестирование веб-приложений

«Как тестировать веб-страницы?» – еще один часто поднимаемый
вопрос. Вот несколько инструментов, которые могут помочь в этом
предприятии:
- Ivonna;
- Team System Web Test;
- Watir;
- Selenium.
Дадим краткое описание каждого.

# Ivonna

Ivonna – вспомогательный каркас для автономного тестирования,
который устраняет необходимость использовать настоящие сеансы
и страницы HTTP при прогоне тестов, относящихся к ASP.NET. За
кулисами он делает удивительные вещи, в том числе компилирует
тестируемые страницы и позволяет проверять содержащиеся в них
элементы управления, не имея сеанса в браузере. Каркас полностью
подделывает всю модель HTTP времени выполнения.
Автономные тесты пишутся точно так же, как при тестировании
любых других объектов в памяти. Не нужно ни веб-сервера, ни прочей гадости.
Ivonna разрабатывается в партнерстве с Typemock и работает как
надстройка над каркасом Typemock Isolator. Домашняя страница
Ivonna находится по адресу http://ivonna.biz.

## Тестирование веб-приложений в Team System

В редакции Visual Studio Team Test и Team Suite встроена возможность записывать и воспроизводить запросы к веб-страницам и попутно проверять различные вещи. Строго говоря, это интеграционное
тестирование, но очень эффективное. В последних версиях появилась
также возможность записывать Ajax-действия на странице, и, кроме
того, работать стало гораздо удобнее.
Дополнительные сведения о Team System можно найти нас странице http://msdn.microsoft.com/en-us/teamsystem/default.aspx.

## Watir

Watir (произносится так же, как «water») расшифровывается как
«web application testing in Ruby» (тестирование веб-приложений в
Ruby). Этот каркас с открытым исходным кодом позволяет описывать последовательность операций в браузере на языке программирования Ruby. Многие рубисты горячо рекомендуют его, но для этого
потребуется изучить совсем новый язык. Впрочем, в ряде проектов
для .NET Watir успешно используется, так что не такая уж это большая проблема.
Домашняя страница Watir находится по адресу http://watir.com/.

## Selenium WebDriver

Selenium – это набор инструментов для автоматизации тестирования веб-приложений на разных платформах. Он старше всех остальных каркасов в моем списке, и его API имеет обертку для .NET.
WebDriver – это расширение Selenium, поддерживающее самые разные браузеры, в том числе мобильные. Очень мощная штука.
Selenium – каркас интеграционного тестирования, весьма популярный. Рекомендую начинать с него. Но предупреждаю: его функциональность очень богата, а кривая обучения крута.
Домашняя страница Selenium находится по адресу http://docs.
seleniumhq.org/ projects/webdriver/

## Coypu

Coypu – абстракция .NET поверх Selenium и других инструментов,
относящихся к тестированию веб-приложений. На момент написания этой книги она только-только появилась, но потенциал велик.
Возможно, стоит познакомиться поближе.
Дополнительные сведения можно найти по адресу https://github.
com/featurist/coypu.

## Capybara

Capybara – написанный на Ruby инструмент для автоматизации браузера. Для этой цели используется API RSpec (в стиле BDD), который многие находят прелестным.
Каркас Selenium более зрелый, но Capybara заманчивее и быстро
прогрессирует. Если я пишу на Ruby, то пользуюсь именно этим каркасом.
Дополнительные сведения можно найти по адресу https://github.
com/jnicklas/capybara.

## Тестирование JavaScript

Для тех, кто собирается писать автономные или приемочные тесты
для JavaScript-кода есть несколько инструментов. Отметим, что для
работы с большинством из них требуется установить на машину Node.
JS, но в наши дни это перестало быть сложной проблемой. Просто
зайдите на страницу http://nodejs.org/download/.
Вот неполный перечень каркасов, на которые стоит взглянуть.

- JSCover. Используется для проверки покрытия JavaScript-кода
тестами. http://tntim96.github.com/JSCover/
- Jasmin. Очень известный каркас в стиле BDD, с которым мне
доводилось работать. Рекомендую. http://pivotal.github.io/
jasmine/.
- Sinon.JS. Создает подделки на JS. http://sinonjs.org/.
- CasperJS + PhantomJS. Используется для тестирования поведения JavaScript в браузере на машине без монитора и клавиатуры. Да, это не опечатка – реальный браузер не нужен (под
капотом используется node.js). http://casperjs.org/.
- Mocha. Также широко известен и используется во многих проектах. http://visionmedia.github.com/mocha/.
- QUnit. Не первой молодости, но все еще хороший каркас тестирования. http://qunitjs.com/.
- Buster.JS. Совсем новый каркас. http://docs.busterjs.org/en/
latest/.
- Vows.js. Перспективный, многообещающий каркас. https://
github.com/cloudhead/vows.

## Тестирование пользовательского интерфейса (персональных приложений)

Тестировать пользовательский интерфейс всегда трудно. Я не очень
верю в автономные или интеграционные тесты пользовательского
интерфейса, потому что отдача очень мала по сравнению с потраченным временем. На мой взгляд, интерфейсы слишком изменчивы для
надежного тестирования. Поэтому я обычно стараюсь вынести всю логику из пользовательского интерфейса на более низкий уровень,
который можно автономно протестировать стандартными способами.
Я не могу порекомендовать никаких инструментов в этом сегменте
(которые не побудили бы вас разбить клавиатуру через три месяца
использования).

## Тестирование многопоточных приложений

Потоки всегда были костью в горле для автономного тестирования.
Ну не тестируются они – и все тут. Именно поэтому появляются новые каркасы, которые позволяют тестировать относящуюся к потокам логику (взаимоблокировки, состояния гонки и т. д.). Приведу два
примера.

- Microsoft CHESS;
- Osherove.ThreadTester.

## Microsoft CHESS

CHESS – перспективный инструмент, исходный код которого частично открыт Microsoft на сайте Codeplex.com. CHESS пытается
обнаружить в коде ошибки, связанные с многопоточностью (взаимоблокировки, зависания, активные блокировки и т. д.), пробуя всевозможные перестановки порядка выполнения потоков. Такие тесты
пишутся как обычные автономные тесты.
Домашняя страница находится по адресу http://chesstool.codeplex.
com.

## Osherove.ThreadTester

Это небольшой каркас с открытым исходным кодом, который я разработал некоторое время назад. Он позволяет запускать в одном тесте
несколько потоков и смотреть, не произошло ли в коде что-то странное (к примеру, взаимоблокировка). Его функциональность не очень
богата, это лишь попытка реализовать многопоточный тест (а не тест
многопоточного кода).
Скачать каркас можно из моего блога по адресу http://osherove.
com/blog/2007/6/22/multithreaded-unit-tests-with-osherovethreadtester.html.

## Приемочное тестирование

Приемочное тестирование способствует более тесному сотрудничеству заказчиков и разработчиков программного обеспечения.
В ходе этой деятельности заказчики, тестировщики и разработчики
начинают лучше понимать, что должна делать программа, а тесты
автоматически сравнивают полученные результаты с ожидаемыми.
Это прекрасный способ совместной работы над сложными задачами (и нахождения правильных решений) на ранних стадиях разработки.
К сожалению, существует не так много каркасов для автоматизированного приемочного тестирования, и лишь один действительно
работает! Надеюсь, что скоро положение дел изменится. Вот список
достойных внимания каркасов:
- FitNesse;
- SpecFlow;
- Cucumber;
- TickSpec.

## FitNesse

FitNesse — не требовательный к ресурсам каркас с открытым исходным кодом, который по идее должен упростить разработчикам определение приемочных тестов – в виде веб-страниц, содержащих простые таблицы входных данных и ожидаемых результатов, – прогон
тестов и отображение результатов.
FitNesse содержит много ошибок, но тем не менее используется в
разных местах с переменным успехом. Лично мне не удалось заставить его работать нормально.
Дополнительные сведения о FitNesse можно найти на сайте www.
fitnesse.org.

## SpecFlow

SpecFlow – попытка привнести в мир .NET то, чем Cucumber облагодетельствовал мир Ruby: инструмент, с помощью которого можно
писать спецификации в виде простых текстовых файлов, привлекая
к работе заказчиков и отдел контроля качества.
С этой работой он неплохо справляется. Подробности см. на сайте
http://www.specflow.org.

## Cucumber

Cucumber – основанный на Ruby инструмент, позволяющий писать
спецификации на специальном языке Gherkin (согласен, не звучит).
Это обычные текстовые файлы, для которых затем нужно написать
связующий код, который будет исполнять фактический код, воздействующий на код приложения.
Кажется сложным, но на самом деле это не так.
Но что здесь делает инструмент для Ruby? Дело в том, что он послужил источником вдохновения для целого семейства новых инструментов в мире .NET, из которых на данный момент, похоже, выжил
только один – SpecFlow.
Однако существует способ исполнять Cucumber на платформе
.NET, если вы используете IronRuby – язык, который Microsoft начала разрабатывать и бросила, отдав на растерзание поклонникам
открытого исходного кода, чтобы никогда больше о нем не слышать
(отличная работа!).
Как бы то ни было, Cucumber достаточно важен, чтобы знать о нем,
пусть даже вы и не собираетесь им пользоваться. Он поможет понять,
почему на платформе .NET пытаются сделать то же самое.
Кроме того, Cucumber лежит в основе языка Gherkin, который пытаются реализовать некоторые нынешние и будущие инструменты.
Читайте подробности на http://cukes.info/.

## TickSpec

TickSpec интересен тем, кто работает на F#. Сам я его не использовал,
потому что не пишу на F#, но знаю, что он из того же ряда каркасов
приемочного тестирования в стиле BDD, что и все вышеупомянутые.
Я не слыхал, чтобы кто-то им пользовался, но, быть может, это потому, что я не вращаюсь в кругах, близких к F#. Подробности см. на
сайте https://tickspec.codeplex.com/.

## Каркасы с API в стиле BDD

В последние годы появилась целая плеяда каркасов, имитирующих
еще один инструмент из мира Ruby – RSpec. Этот инструмент возвестил миру о том, что, быть может, автономное тестирование – на
такое уж удачное название, и что, заменив его на BDD (behaviourdriven development – разработка через поведение), мы сможем повысить удобочитаемость и, чем черт не шутит, даже более осмысленно
общаться с заказчиками на тему поведения программы.
На мой взгляд, идея реализовать эти каркасы просто как другие
API, с помощью которых можно писать автономные или интеграционные тесты, уже отрицает саму возможность больше (чем раньше)
общаться с заказчиками, потому что заказчики вряд ли будут читать
или изменять ваш код. Я полагаю, что каркасы приемочного тестирования, описанные в предыдущем разделе, куда лучше отвечают этому
направлению мыслей.
Таким образом, остаются только кодировщики, пытающиеся использовать новые API.
Поскольку эти API черпают вдохновение из языка Cucumber, построенного в стиле BDD, иногда они получаются более удобочитаемыми, но, на мой взгляд, не в простых случаях, для которых лучше
подходит незамысловатый стиль утверждений. Вы можете думать
иначе.
Перечислю несколько наиболее известных каркасов в стиле BDD.
Я не стал описывать их в специальных подразделах, потому что не
использовал ни один из них в реальном проекте сколько-нибудь долго.

- NSpec – самый почтенный, но все еще, похоже, в хорошей форме. Подробности на http://nspec.org/.
- StoryQ – еще один старичок-бодрячок. Порождает в высшей
степени удобочитаемый результат и включает также инструмент для трансляции написанных на Gherkin историй в компилируемый код тестов. Подробности на http://storyq.codeplex.
com/.
- MSpec, или Machine.Specifications, пытается как можно ближе
соответствовать источнику (RSpec), применяя многочисленные трюки с лямбда-выражениями. Затягивает. Подробности
на https://github.com/machine/machine.specifications.
- TickSpec – та же идея, но реализованная для F#. Подробности
на http://tickspec.codeplex.com/.







