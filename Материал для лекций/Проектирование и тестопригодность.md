# Проектирование и тестопригодность

В этой главе:
 - Преимущества учета тестопригодности при проектировании.
 - Плюсы и минусы проектирования с учетом тестопригодности.
 - Как быть с проектами, трудными для тестирования.

Перепроектирование программы с целью сделать ее более тестопригодной – больная тема для некоторых разработчиков. В этой главе
мы рассмотрим основные идеи и методы проектирования с учетом
тестопригодности. Мы также поговорим о плюсах и минусах этого
подхода и о том, когда он имеет смысл.
Но сначала зададимся вопросом, зачем вообще нужно учитывать
тестопригодность при проектировании.


## Почему я должен думать о тестопригодности в своем проекте?

Законный вопрос. Проектируя программу, мы должны думать о том,
что она должна делать и каких результатов может ожидать конечный
пользователь, – так нас учили. Но тесты программы – еще один вид
пользователя. Этот пользователь предъявляет строгие требования
к программе, но все они вытекают из одного и того же пожелания:
тестопригодности. Это пожелание может изменять проект разными
способами, по большей части – к лучшему.
В тестопригодном проекте каждая логическая конструкция (циклы, предложения if, switch и т. д.) должна быть устроена так, чтобы
для нее можно было легко и быстро написать автономный тест, обладающий следующими свойствами:

- работает быстро;
- изолирован, т. е. может быть выполнен независимо или в составе группы тестов, до или после любого другого теста;
- не требует конфигурирования внешней системы;
- при любом прогоне дает один и тот же результат – прошел или
не прошел.

Эту совокупность свойств иногда называют FICC: fast (быстрый),
isolated (изолированный), configuration-free (без конфигурирования),
consistent (стабильный). Если писать такой тест трудно или долго,
система не может считаться тестопригодной.
Если представлять себе тесты как пользователя системы, то проектирование с учетом тестопригодности становится образом мыслей.
Если бы вы разрабатывали систему через тестирование, то она автоматически получилась бы тестопригодной, потому что в этом случае
тесты пишутся сначала и в значительной степени определяют структуру API системы, вынуждая делать ее такой, чтобы тесты могли с
ней работать.
Теперь, понимая, что такое тестопригодное проектирование, посмотрим, что оно влечет за собой, обсудим его плюсы и минусы, рассмотрим альтернативы и приведем пример проекта, который трудно
тестировать.

## Цели проектирования с учетом тестопригодности

Существует несколько моментов, способных сделать проект существенно более тестопригодным. Роберт С. Мартин составил хороший
список целей проектирования объектно-ориентированных систем,
легший в основу проектов, рассматриваемых в этой главе. См. его
статью «Principles of OOD» на странице http://butunclebob.com/
ArticleS.UncleBob.PrinciplesOfOod.
Мои рекомендации по большей части сводятся к включению в код
зазоров – мест, куда можно будет внедрить другой код или подменить
Существует несколько моментов, способных сделать проект существенно более тестопригодным. Роберт С. Мартин составил хороший
список целей проектирования объектно-ориентированных систем,
легший в основу проектов, рассматриваемых в этой главе. См. его
статью «Principles of OOD» на странице http://butunclebob.com/
ArticleS.UncleBob.PrinciplesOfOod.
Мои рекомендации по большей части сводятся к включению в код
зазоров – мест, куда можно будет внедрить другой код или подменить 

Таблица 11.1. Рекомендации по тестопригодному проектированию
|Рекомендация   | Преимущества   |
|:--|:--|
|По умолчанию делайте методы виртуальными.   |Это позволит переопределить методы в производном классе для целей тестирования. Переопределение дает возможность изменить поведение или разорвать внешнюю зависимость.   |
|Проектируйте на основе интерфейсов. |Это позволит использовать полиморфизм для подмены зависимостей заглушками и подставками. |
|По умолчанию делайте классы незапечатанными.|Если класс запечатан (%nal в Java), то переопределить его виртуальные методы невозможно.|
|Избегайте создания экземпляров конкретных классов внутри методов, содержащих логику. Получайте экземпляры классов от вспомогательных методов, фабрик, DI-контейнеров типа Unity или иных мест, но не создавайте их напрямую.| Это позволит подсовывать поддельные экземпляры классов методам, которые в них нуждаются, не связывая себя внутренней реализацией порождения экземпляра.
|Избегайте прямых обращений к статическим методам. Предпочитайте вызовы методов экземпляра, из которых уже вызываются статические методы.| Это позволит разорвать зависимость от статических методов путем переопределения методов экземпляра (переопределить статический метод невозможно).|
|Избегайте конструкторов и статических конструкторов, содержащих логику|Реализовать переопределение конструкторов трудно. Чем проще конструктор, тем легче унаследовать классу в тестах.|
|Отделяйте логику объектов-одиночек (синглтонов) от логики их создания|Если имеется одиночка, то должен быть способ подменить его экземпляр, чтобы можно было внедрить заглушку или вернуть объект в исходное состояние.


## По умолчанию делайте методы виртуальными

В Java методы по умолчанию виртуальны, но на платформе .NET разработчики не такие везучие. В .NET, чтобы можно было переопределить поведение метода, необходимо явно сделать его виртуальным.
В таком случае можно будет воспользоваться техникой «выделить и
переопределить», описанной в главе 3.
Альтернативой этому способу является вызов пользовательского
делегата из класса. Этот делегат можно будет подменить извне, установив свойство или передав параметр конструктору или методу. Это
не самый распространенный подход, но некоторые системные проектировщики считают его приемлемым. В листинге ниже приведен
пример класса с делегатом, который в тесте можно подменить.

Листинг 11.1. Класс, вызывающий делегат, который можно подменить
в тесте

```C#
public class MyOverridableClass
{
 public Func<int,int> calculateMethod=delegate(int i)
 {
 return i*2;
 };
 public void DoSomeAction(int input)
 {
 int result = calculateMethod(input);
 if (result==-1)
 {
 throw new Exception(“input was invalid”);
 }
 // 
 }
}
[Test]
[ExpectedException(typeof(Exception))]
public void DoSomething_GivenInvalidInput_ThrowsException()
{

```

MyOverridableClass c = new MyOverridableClass();
 int SOME_NUMBER=1;
 // 
 c.calculateMethod = delegate(int i) { return -1; };
 c.DoSomeAction(SOME_NUMBER);
}

Использовать виртуальные методы удобно, но проектирование на
основе интерфейсов – не менее удачное решение, как поясняется в
следующем разделе.

## Проектируйте на основе интерфейсов

Выявление в приложении «ролей» и их абстрагирование в виде интерфейсов – важная часть процесса проектирования. Абстрактный класс
не должен вызывать никакие конкретные классы, а конкретные классы
могут вызывать только конкретные классы, являющиеся объектами данных (т. е. объекты, не имеющего никакого поведения, а служащие лишь
для хранения данных). Это позволяет организовать в приложении многочисленные зазоры, куда можно подставить собственную реализацию.
Примеры такой подмены реализаций интерфейсов приведены в
главах 3–5.

## По умолчанию делайте классы незапечатанными

 Некоторым программистам психологически трудно делать классы
незапечатанными, потому что они предпочитают полностью управлять тем, кто и кому может наследовать в приложении. Беда в том, что
если классу нельзя унаследовать, то не получится и переопределить
его виртуальные методы.
Иногда этому правилу не удается следовать из соображений безопасности, но вообще его соблюдение должно стать правилом, а не
исключением.

##  Избегайте создания экземпляров конкретных классов внутри методов, содержащих логику

Иногда психологически трудно избежать создания экземпляров конкретных классов внутри методов, содержащих логику, просто потому что вы к этому привыкли. Причина же в том, что тестам может понадобиться управлять тем, какой экземпляр создается в тестируемом
классе. Если не существует зазора, из которого возвращается экземпляр, то задача существенно усложняется – приходится использовать
неограниченные изолирующие каркасы типа Typemock Isolator. Например, если методу нужен объект протоколирования, не создавайте
его внутри метода. Получите объект от простого фабричного метода
и сделайте этот метод виртуальным, чтобы впоследствии его можно
было переопределить и таким образом предоставить методу то, что
удобно тесту. Или же воспользуйтесь не виртуальным методом, а инверсией зависимости через конструктор. Эти и другие способы внедрения обсуждаются в главе 3.

## Избегайте прямых обращений к статическим методам

Попытайтесь абстрагировать прямые зависимости, которые было бы
трудно подменить во время выполнения. В большинстве статических
языков, в частности в VB.NET и C#, подменить поведение статического метода трудно или громоздко. Абстрагирование статических
методов с помощью техники «выделить и переопределить» (см. раздел 3.4 в главе 3) – один из способов решения проблемы.
Более радикальный подход – вообще избегать статических методов.
Тогда любая логика является частью экземпляра класса, и подменить
ее становится проще. Невозможность подмены – одна из причин, почему некоторые программисты, практикующие автономное тестирование или TDD, не любят объекты-одиночки – они выступают в роли
открытого разделяемого ресурса, по природе своей статического, который трудно переопределить.
Полностью отказаться от статического методов тоже трудно, но, попытавшись свести к минимуму число одиночек и статических методов
в приложении, вы упростите себе жизнь во время тестирования.

## Избегайте конструкторов и статических конструкторов, содержащих логику

Классы, предназначенные для конфигурирования, часто делаются
статическими или одиночками, потому что они используются в самых разных частях приложения. Поэтому подменить такие классы во время тестирования трудно. Один из способов решения этой проблемы – воспользоваться той или иной формой контейнеров инверсии управления (IoC) (Microsoft Unity, Autofac, Ninject, StructureMap, Spring.NET или Castle Windsor – все это каркасы для .NET с
открытым исходным кодом).
Эти контейнеры много чего умеют, но все они предоставляют общую умную фабрику, которая позволяет получать экземпляры классов, не зная, является ли экземпляр объектом-одиночкой и как он
реализован. Вы просите интерфейс (обычно в конструкторе) и автоматически получаете объект, который этот интерфейс реализует.
Использование IoC-контейнера (их еще называют DI-контейнерами) позволяет абстрагировать управление временем жизни объекта и
упрощает создание объектной модели, основанной главным образом
на интерфейсах, поскольку контейнер автоматически разрешает все
зависимости класса.
Подробное обсуждение контейнеров выходит за рамки этой книги,
но их полный перечень и некоторые отправные точки можно найти в
статье «List of .NET Dependency Injection Containers (IOC)» в блоге
Скотта Ханселмана (Scott Hanselman): http://www.hanselman.com/
blog/ListOfNETDependencyInjection ContainersIOC.aspx.

## Отделяйте логику объектов-одиночек от логики их создания

Планируя использовать в проекте класс-одиночку, отделяйте логику самого класса от логики создания его экземпляра (например, той
части, где инициализируется статическая переменная), помещая то
и другое в разные классы. Тогда вы, с одной стороны, не отступите
от принципа единственной обязанности (SRP), а, с другой, оставите
способ переопределить логику одиночки.
Например, в листинге 11.2 показан класс-одиночка, а в листинге 11.3 – результат его рефакторинга для повышения тестопригодности.

Листинг 11.2. Нетестопригодный класс-одиночка

```C#

public class MySingleton
{
 private static MySingleton _instance;
 public static MySingleton Instance
 {
 get

 {
 if (_instance == null)
 {
 _instance = new MySingleton();
 }
 return _instance;
 }
 }
}

```

Листинг 11.3. Тестопригодный класс-одиночка после рефакторинга

```C#

public class RealSingletonLogic
{
 public void Foo()
 {
 //

 }
}
public class MySingletonHolder
{
 private static RealSingletonLogic _instance;
 public static RealSingletonLogic Instance
 {
 get
 {
 if (_instance == null)
 {
 _instance = new RealSingletonLogic();
 }
 return _instance;
 }
 }
}

```

Рассмотрев некоторые способы обеспечения тестопригодности
проекта, вернемся к общей картине. А надо ли все это делать, нет ли
каких-нибудь негативных последствий?

## Плюсы и минусы проектирования с учетом тестопригодности

Проектирование с учетом тестопригодности – для многих больной
вопрос. Одни считают, что тестопригодность должна быть одним из обязательных свойств проекта, другие – что проект не должен «страдать» от того, что кому-то взбредет в голову его тестировать.
Важно понять, что сама по себе тестопригодность – не конечная
цель, а лишь побочный продукт определенной школы мысли, которая
практикует принципы тестопригодного объектно-ориентированного
проектирования, изложенные Робертом С. Мартином (и упомянутые
в начале раздела 11.2). В проекте, где расширяемость и абстракции
классов занимают одно из первых мест, легко найти зазоры для действий, относящихся к тестированию. Все рассмотренные в этой главе
приемы прекрасно согласованы с принципами Мартина: классы, чье
поведение можно изменять путем наследования и переопределения
или путем внедрения интерфейса, являются «открытыми для расширения, но закрытыми для модификации» – это принцип открытости-закрытости. Такие классы обычно отвечают также принципам
внедрения зависимости и инверсии управления, чтобы поддержать
внедрение через конструктор. Применяя принцип единственной
обязанности, мы можем, например, отделить сам класс-одиночку от
логики его создания. И лишь принцип подстановки Лисков одиноко
стоит в сторонке, потому что я не смог придумать ни одного примера, где его нарушение нарушает также тестопригодность. Но из того
факта, что ваш тестопригодный проект по видимости коррелирует с
принципами SOLID, еще не следует, что этот проект хорош или что
вы в совершенстве овладели искусством проектирования. Вовсе нет.
Скорее всего, ваш проект, как и мой, можно улучшить. Возьмите
какую-нибудь достойную книгу по этому предмету, например, Eric
Evans «Domain-Driven Design: Tackling Complexity in the Heart of
Software»1
 (Addison-Wesley Professional, 2003) или Joshua Kerievsky
«Refactoring to Patterns»2
 (Addison-Wesley Professional, 2004). А как
насчет «Чистого кода» Роберта Мартина? Тоже годится!
Я встречал чертову уйму ужасно спроектированного и в высшей
степени тестопригодного кода. Лишнее доказательство того, что TDD
без должных знаний о проектировании не обязательно приносит хорошие плоды.
Вопрос, тем не менее, остается – верно ли, что это лучший способ
работы? Каковы недостатки методики тестопригодного проектирования? Как быть, если код унаследован? И так далее.

## Объем работы

В большинстве случаев проектирование с учетом тестопригодности
занимает больше времени, потому что обычно при этом приходится
писать больше кода. Даже дядюшка Боб в своих пространных и временами забавных видеороликах на сайте http://cleancoders.com любит
говаривать (голосом Шерлока Холмса, держа в руке трубку), что он
начинает с упрощенного дизайна, который делает нечто простейшим
из возможных способов, а рефакторингом занимается, только когда
видит в этом необходимость.
Вы можете возразить, что дополнительное проектирование, требуемое для обеспечения тестопригодности, высвечивает проблемы, которые вы раньше не рассматривали и которые в любом случае стоило
бы учесть в проекте (разделение функций, принцип единственной
обязанности и т. д.).
С другой стороны, в предположении что вы и так довольны своим
проектом, вносить изменения, не относящиеся к функциональности
продукта, только ради тестопригодности может оказаться проблематично. Но и тут можно возразить, что код тестов важен не меньше, чем
продуктовый, так как раскрывает характеристики API, описывающего модель предметной области, и заставляет думать о том, как другие
люди будут использовать ваш код.
Начиная с этого места, дискуссии на эту тему редко оказываются
продуктивными. Остановимся на том, что для обеспечения тестопригодности действительно требуется больше кода и больше работы, но
зато при этом мы вынуждены задумываться о пользователях своего
API – и это хорошо.

## Сложность

При проектировании с учетом тестопригодности иногда возникает
ощущение, что вы чуточку (а, может, вовсе и не чуточку) переусложняете. То ловите себя на добавлении интерфейсов туда, где им вроде
бы не место, то раскрывается семантика поведения класса, хотя вы
этого вовсе не хотели. А когда абстрагируется слишком много интерфейсов, искать в коде, где же все-таки находится истинная реализация метода, становится мукой мученической.
Можно было бы возразить, что есть инструменты типа ReSharper,
которые значительно упрощают навигацию, и потому этот аргумент
уже не актуален. Согласен, что большинство проблем навигации они решают. Наличие подходящего для работы инструмента вообще
очень помогает.

## Раскрытие секретной интеллектуальной собственности

Во многих проектах воплощена интеллектуальная собственность,
которая должна оставаться секретной, но при проектировании с учетом тестопригодности что-то неизбежно раскрывается, например,
информация о защите или лицензировании или запатентованные
алгоритмы. Есть, конечно, обходные пути – сделать соответствующие части программы внутренними и воспользоваться атрибутом
[InternalsVisibleTo], но они по сути своей подрывают саму идею
тестопригодного проектирования. Мы изменяем проект, но все равно
сохраняем часть логики скрытой. И зачем тогда было все затевать?
В этом отношении идея проектирования с учетом тестопригодности действительно дает небольшой сбой. Иногда обойти проблемы,
связанные с безопасностью или патентной защитой, не получается.
Тогда нужно что-то изменить или пойти на компромисс.

## Иногда нет никакой возможности

Иногда существуют политические или иные причины, навязывающие определенный способ проектирования, и поделать с этим ничего
нельзя (есть кто из «Выматываем душу, Инк.»?). Бывает и так, что
просто нет времени на переработку проекта или проект настолько
хрупок, что перерабатывать его боязно. Это еще один случай, когда
проектирование с учетом тестопригодности не годится – мешает окружение. Тут мы имеем пример факторов влияния, которые рассматривались в главе 9.
Рассмотрев аргументы за и против, обратимся к альтернативам тестопригодному проектированию.

## Альтернативы проектированию с учетом тестопригодности

Интересно посмотреть, как решается проблема в других языках.
Код, написанный на динамических языках типа Ruby или Smalltalk,
изначально тестопригоден, потому что во время выполнения можно подменить все, что угодно. Работая с таким языком, можно проектировать, как вам нравится, не задумываясь о тестопригодности. Чтобы
подменить что-то, не нужно заводить интерфейс, а допускающий переопределение метод не обязан быть открытым. Можно даже динамически изменять поведение базовых типов, и никто не станет ругаться,
что код не компилируется.
В мире, где все тестопригодно, нужно ли учитывать это при проектировании? Вы, конечно, ожидаете ответа «нет». Мол, в таком мире
мы вольны выбирать проект, сообразуясь с собственным вкусом.

## К вопросу о проектировании в динамически типизированных языках

Интересно, однако, что, начиная с 2010 года, в сообществе Ruby, к
которому я тоже когда-то принадлежал, все чаще ведутся разговоры
о принципах проектирования SOLID (единственной обязанности,
открытости-закрытости, подстановки Лисков, разделения интерфейсов и инверсии зависимости). «Могу – не значит должен», говорят некоторые рубисты, например Авди Гримм (Avdi Grimm), автор
книги «Objects on Rails», выложенной на сайте http://objectsonrails.
com. В блогах можно найти немало размышлений о состоянии дел с
проектированием в сообществе Rails, например, на странице http://
jamesgolick.com/2012/5/22/objectify-a-better-way-to-build-railsapplications.html. Другие рубисты на это отвечают: «Отстаньте от
нас со своим переинженирингом». Так, Дэвид Хейнемейер Ханссон
(David Heinemeier Hansson), он же DHH, создатель каркаса Ruby
on Rails, обсуждает эту тему в своей статье «Dependency injection is
not a virtue» (Внедрение зависимости – не добродетель) по адресу
http://david.heinemeierhansson.com/2012/dependency-injection-isnot-avirtue.html.
Можете представить, какое оживление это вызывает в Твиттере.
Забавно, что все эти споры напоминают мне то, что происходило в
2008–2009 годах в сообществе .NET, а особенно в рядах недавно почившего движения ALT.NET (большая часть активистов ALT.NET открыла для себя Ruby или Node.js и отдалилась от .NET, правда, через
год вернулась – «ради денег». Каюсь, сам виновен!). Но существенная
разница состоит в том, что мы говорим о Ruby. В сообществе .NET
хотя бы были пусть и не вполне убедительные аргументы в пользу
сторонников лозунга «За SOLID-ное проектирование»: например, невозможно протестировать проект без классов, отвечающих принципу открытости-закрытости, потому что компилятор нарявкает. Так что
проектировщики говорили: «Ну видишь? Даже компилятор говорит,
что твой дизайн – отстой». В ретроспективе это звучит довольно глупо, потому что есть сколько угодно тестопригодных проектов, являющихся, тем не менее, в высшей степени отстойными. А теперь приходят ребята, пишущие на Ruby, и говорят, что хотят использовать
принципы SOLID? На хрена им это нужно?
Похоже, использование SOLID сулит кое-какие дополнительные
выгоды: код становится проще понять и сопровождать, а в мире Ruby
это может оказаться очень серьезной проблемой. Иногда даже более
серьезной, чем в статически типизированных языках, потому что в
Ruby динамическая программа может вызывать глубоко скрытый переадресованный код, и тогда сам черт ногу сломит. Тесты помогают,
но лишь до определенного предела.
Ну, а что я думал на этот счет? Сложилось так, что поначалу программисты, пишущие на Ruby, вообще не задумывались о тестопригодности дизайна, потому что код и так уже был тестопригодным.
И все было хорошо, пока они не открыли для себя идеи проектирования кода; оказалось, что проектирование – самостоятельная деятельность, которая отнюдь не сводится к простому рефакторингу, связанному с тестопригодностью.
Но вернемся к .NET и к статически типизированным языкам:
возьмем какую-нибудь технологию на платформе .NET, которая показывает, как использование инструментов может изменить способ
осмысления задач и иногда сделать трудную проблему тривиальной.
В мире, где памятью управляют за вас, нужно ли учитывать в проекте
управление памятью? Как правило, нет. При работе с языком, в котором автоматического управления памятью нет (например, C++), необходимо помнить об оптимизации и своевременном освобождении
памяти, иначе приложению будет худо. Но это не помешает хорошо
спроектировать программу, не в управлении памятью дело. Важны
совсем другие вещи: удобочитаемость кода, удобство пользования и
т. д. Вы не прибегаете к воображаемому противнику, аргументируя
выбор проектных решений, потому что, обосновывая свою позицию,
возможно, опираетесь не на ту подпорку (слишком много метафор?
Да-да, я знаю. Это как… да нет, ничего).
Точно так же, следуя принципам объектно-ориентированного проектирования, обеспечивающим тестопригодность, вы можете получить тестопригодный проект в качестве побочного продукта, хотя
цели такой и не ставили. Проект предназначается для решения конкретной задачи. Если под рукой имеется инструмент, который решает за вас проблему тестопригодности, то специально учитывать этот
аспект при проектировании нет нужды. У проектов есть и другие достоинства, но они должны быть результатом осознанного выбора, а не
просто данностью.
Основная проблема нетестопригодного проекта состоит в невозможности подменить зависимости во время выполнения. Именно
поэтому мы создаем интерфейсы, делаем методы виртуальными и
занимаемся другими подобными вещами. На платформе .NET существуют инструменты, которые умеют подменять зависимости без рефакторинга с целью обеспечения тестопригодности, – неограниченные изолирующие каркасы.
Означает ли наличие неограниченных каркасов, что учитывать
тестопригодность при проектировании не нужно? В каком-то смысле
да. Это избавляет от необходимости включать тестопригодность в состав целей проектирования. У объектно-ориентированных принципов, выдвинутых Бобом Мартином, есть замечательные достоинства,
и следовать им нужно не потому, что они обеспечивают тестопригодность, а потому что в применении к проектированию они разумны и
целесообразны. Они упрощают разработку, чтение и сопровождение
кода, даже если тестопригодность не ставится во главу угла.
Завершим это обсуждение примером проекта, который с трудом
поддается тестированию.

## Пример проекта, трудного для тестирования

Легко найти интересные проекты, в которых можно покопаться. Один
такой проект – BlogEngine.NET, исходный код которого находится по
адресу http://blogengine.codeplex.com/SourceControl/latest. Можно
сразу определить, использовалась ли при создании проекта методика
разработки через тестирование и задумывались ли авторы о тестопригодности. В данном случае по всему коду разбросаны статические
классы, статические методы, статические конструкторы. С точки зрения проектирования, это не так уж плохо. Но напомню, эта книга не
о проектировании. А вот если говорить о тестопригодности, то такой
подход неудачен.
Взгляните всего на один класс из решения: класс Manager в пространстве имен Ping (http://blogengine.codeplex.com/SourceControl/
latest#BlogEngine/BlogEngine. Core/Ping/Manager.cs):

```C#

namespace BlogEngine.Core.Ping
{
 using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text.RegularExpressions;
 public static class Manager
 {
 private static readonly Regex TrackbackLinkRegex = new Regex(
 “trackback:ping=\”([^\”]+)\””, RegexOptions.IgnoreCase |
 RegexOptions.Compiled);
 private static readonly Regex UrlsRegex = new Regex(
 @”<a.*?href=[“”’](?<url>.*?)[“”’].*?>(?<name>.*?)</a>”,
 RegexOptions.IgnoreCase | RegexOptions.Compiled);
 public static void Send(IPublishable item, Uri itemUrl)
 {
 foreach (var url in GetUrlsFromContent(item.Content))
 {
 var trackbackSent = false;
 if (BlogSettings.Instance.EnableTrackBackSend)
 {
 // ignoreRemoteDownloadSettings true
 // Utils.DownloadWebPage.
 var remoteFile = new RemoteFile(url, true);
 var pageContent = remoteFile.GetFileAsString();
 var trackbackUrl = GetTrackBackUrlFromPage(pageContent);
 if (trackbackUrl != null)
 {
 var message =
 new TrackbackMessage(item, trackbackUrl, itemUrl);
 trackbackSent = Trackback.Send(message);
 }
 }
 if (!trackbackSent &&
 BlogSettings.Instance.EnablePingBackSend)
 {
 Pingback.Send(itemUrl, url);
 }
 }
 }
 private static Uri GetTrackBackUrlFromPage(string input)
 {
 var url =
 TrackbackLinkRegex.Match(input).Groups[1].ToString().Trim();
 Uri uri;

 return
 Uri.TryCreate(url, UriKind.Absolute, out uri) ? uri : null;
 }
 private static IEnumerable<Uri> GetUrlsFromContent(string content)
 {
 var urlsList = new List<Uri>();
 foreach (var url in
 UrlsRegex.Matches(content).Cast<Match>().Select(myMatch =>
 myMatch.Groups[“url”].ToString().Trim()))
 {
 Uri uri;
 if (Uri.TryCreate(url, UriKind.Absolute, out uri))
 {
 urlsList.Add(uri);
 }
 }
 return urlsList;
 }
 }
}

```

Мы сосредоточимся на методе Send класса Manager . Предполагается, что этот метод посылает какой-то сигнал прозвона или трассировки (что это такое, нам сейчас не важно), если обнаруживает в посте
пользователя какие-то из перечисленных URL-адресов.
В этом методе реализовано много требований:

- посылать отклик, только если в глобальном объекте конфигурации некоторое свойство равно true;
- если сигнал прозвона не послан, попробовать послать сигнал
трассировки;
- посылать сигнал прозвона или трассировки для любого URLадреса, обнаруженного в тексте поста.

Почему я считаю, что этот метод трудно тестировать? По нескольким причинам.

- Все зависимости (например, от конфигурации) – статические
методы, поэтому без неограниченного каркаса их трудно подделать и подменить.
- Даже если бы удалось подделать зависимости, их невозможно
внедрить через параметры или свойства. Они используются
непосредственно.
- Можно было бы попробовать воспользоваться техникой «выделить и переопределить» (см. главу 3), чтобы вызывать зависимости с помощью виртуальных методов, которые переопределяются в производном классе, только вот класс Manager
статический, поэтому никаких нестатических, а уж тем более
виртуальных методов в нем быть не может. Так что выделить и
переопределить не удастся.
- Даже если бы этот класс не был статическим, статическим
является метод, который мы хотим протестировать. А чтобы
можно было применить технику «выделить и переопределить», нам нужен метод экземпляра. Опять облом.

Вот как я подошел бы к рефакторингу этого класса (в предположении, что имеются интеграционные тесты).

1. Сделать класс нестатическим.
2. Создать нестатическую копию метода Send() с теми же самыми параметрами. Я бы назвал ее InstanceSend(), чтобы при
компиляции не возникало конфликтов с исходным статическим методом.
3. Удалить весь код из исходного статического метода, заменив
его на new Manager().InstanceSend(item, itemUrl);, так
что статический метод станет просто механизмом перенаправления. При этом прежний код, из которого этот метод вызывается, не сломается (это же рефакторинг!).
4. Имея нестатический класс и метод экземпляра в нем, я могу
применить технику «выделить и переопределить» к частям
метода InstanceSend() и тем самым разорвать зависимости,
например, выделить обращение к BlogSettings.Instance.
EnableTrackBackSend в отдельный виртуальный метод, который затем можно будет переопределить в классе, производном
от Manager.
5. Я еще не закончил, но просвет уже виден. Теперь можно продолжить рефакторинг и выделение с переопределением.

Вот как выглядит класс, перед тем как я начну выделять и переопределять.

```C#

public static class Manager
{
 …
 public static void Send(IPublishable item, Uri itemUrl)
 {
 new Manager().InstanceSend(item,itemUrl);
 }
 public static void InstanceSend(IPublishable item, Uri itemUrl)
 {

   foreach (var url in GetUrlsFromContent(item.Content))
 {
 var trackbackSent = false;
 if (BlogSettings.Instance.EnableTrackBackSend)
 {
 // ignoreRemoteDownloadSettings  
 
 true
 //  
 

  Utils.DownloadWebPage.
 var remoteFile = new RemoteFile(url, true);
 var pageContent = remoteFile.GetFileAsString();
 var trackbackUrl = GetTrackBackUrlFromPage(pageContent);
 if (trackbackUrl != null)
 {
 var message =
 new TrackbackMessage(item, trackbackUrl, itemUrl);
 trackbackSent = Trackback.Send(message);
 }
 }
 if (!trackbackSent && BlogSettings.Instance.EnablePingBackSend)
 {
 Pingback.Send(itemUrl, url);
 }
 }
 }
 private static Uri GetTrackBackUrlFromPage(string input)
 {
 …
 }
 private static IEnumerable<Uri> GetUrlsFromContent(string content)
 {
 …
 }
}

```

Вот несколько вещей, которые помогли бы сделать этот класс более тестопригодным:

- По умолчанию классы должны быть нестатическими. В C# вообще мало причин для создания чисто статических классов.
- Использовать методы экземпляра, а не статические методы.

## Выводы

В этой главе мы обсуждали идею проектирования с учетом тестопригодности: что это означает с точки зрения приемов проектирования, плюсы и минусы и альтернативы. Простых ответов тут не существует,
но вопросы интересные. Будущее автономного тестирования зависит
от того, как люди станут решать эти проблемы и какие инструменты
появятся в качестве альтернатив.
Тестопригодность проекта обычно существенна только в статических языках типа C# и VB.NET, где приходится заранее думать, как
можно будет подменить различные объекты. В динамических языках,
которые изначально гораздо более тестопригодны, учет тестопригодности на этапе проектирования играет куда меньшую роль. В таких
языках почти все можно подменить вне зависимости от исходных
проектных решений. Это избавляет соответствующие сообщества от
необходимости спорить с воображаемым противником о том, означает ли нетестопригодность программы, что она плохо спроектирована,
и сосредоточиться на более глубоких аспектах хорошего проектирования.
В тестопригодном проекте имеются виртуальные методы, незапечатанные классы, интерфейсы и четкое разделение функций. В нем
меньше статических классов и методов и больше экземпляров классов
с логикой. На самом деле, тестопригодный проект следует принципам
SOLID, но это еще не значит, что проект обязательно хороший. Быть
может, пришло время сказать, что конечной целью должна быть не
тестопригодность, а исключительно хороший дизайн.
Мы рассмотрели небольшой пример совершенно нетестопригодного проекта и шаги, которые нужно выполнить, что привести его к
тестопригодному виду. Подумайте, настолько легко было бы его тестировать, если бы при разработке применялась методика TDD! Он
был бы тестопригоден с самой первой строчки кода, и нам не пришлось бы устраивать эти танцы с бубнами.
Мне пора закругляться. Но мир прекрасен и полон вещей, в которые, я уверен, вы с удовольствием запустили бы зубки.

## Дополнительные ресурсы

Я знаю, что многие читатели этой книги проходят следующие стадии.

- Освоившись с соглашениями об именовании, они начинают
перенимать другие или создавать свои собственные. Это хорошо. Мои соглашения хороши для начинающих, а сам я пользуюсь ими до сих пор, но это не единственный путь. Выбирайте
имена тестов, так чтобы вам было комфортно.
- Начинают искать другие формы написания тестов, например каркасы в стиле разработки через поведение (BDD) типа
MSpec или NSpec. Это тоже хорошо, потому что коль скоро
сохранены три важных аспекта (что тестируется, при каких
условиях и каков ожидаемый результат), удобочитаемость не
страдает. В API, построенных на основе BDD, проще организовать единственную точку входа и высказывать утверждения о
нескольких конечных результатах в разных требованиях – получается в высшей степени понятно. Объясняется это тем, что
большинство API на основе BDD допускают иерархическое
написание.
- Начинают автоматизировать больше интеграционных и комплексных тестов, потому что находят, что уровень автономного тестирования слишком низок. И это замечательно, так как
хорошо все, что позволяет вам уверенно вносить изменения в
код. Если в проекте вообще не останется автономных тестов,
но вы тем не менее сохраните способность вести разработку с
высокой скоростью и качеством, это просто отлично, и хорошо
бы мне у вас поучиться. (Это возможно, но, начиная с какогото момента, прогон тестов начинает занимать уж очень много
времени. Мы пока еще не нашли волшебного способа получить
все и сразу.)

Как насчет книг?
В части проектирования эту книгу прекрасно дополняет книга
Steve Freeman, Nat Pryce «Growing Object-Oriented Software, Guided
by Tests».
Хорошим справочником по паттернам и антипаттернам автономного тестирования может служить книга Gerard Meszaros «xUnit Test
Patterns: Refactoring Test Code»3
.
Книга Michael Feathers «Working Effectively with Legacy Code»4
обязательна для чтения, если вам приходится сталкиваться с унаследованным кодом.
На сайте ArtOfUnitTesting.com приведен более полный и постоянно (дважды в год) обновляемый список интересных книг.
Что касается анализа тестов, рекомендую также посмотреть мои
видео, в которых я рассказываю о том, как можно улучшить проекты с открытым исходным кодом. Они выложены по адресу http://
artofunittesting.com/test-reviews/.
Я разместил на сайтах http://ArtOfUnitTesting.com и http://
Osherove.com/Videos еще немало бесплатных видео, анализов тестов,
сеансов парного программирования и докладов на конференциях по
разработке через тестирование. Надеюсь, эта дополнительная информация будет вам полезна.
Возможно, вы захотите записаться на мой мастер-класс по TDD
(доступен также в формате онлайнового потокового видео) на сайте
http://TDDCourse.Osherove.com.
Вы всегда можете связаться со мной через Твиттер (@RoyOsherove)
или напрямую по адресу http://Contact.Osherove.com.
С нетерпением жду весточки от вас!






