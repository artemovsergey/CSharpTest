# Внутреннее устройство изолирующих каркасов

В этой главе:
- Ограниченные и неограниченные каркасы.
- Как работает неограниченный каркас на основе профилировщика.
- Определение полезных качеств хорошего изолирующего каркаса.

В предыдущей главе мы использовали каркас NSubstitute для создания поддельных объектов. В этой главе мы отступим назад и представим общую картину изолирующих каркасов на платформе .NET и
за ее пределами. Мир изолирующих каркасов велик и, решая, какой
выбрать, нужно учитывать разные факторы.
Начнем с простого вопроса: почему у одних каркасов возможности шире, чем у других? Например, одни каркасы умеют подделывать статические методы, а другие – нет. Некоторые каркасы даже
способны подделывать объекты, которые еще не были созданы, другие пребывают в блаженном неведении о таких подвигах. С чего бы
это?

## Ограниченные и неограниченные каркасы

Изолирующие каркасы в .NET (а также в Java, C++ и других статических языках) можно отнести к двум основным группам – по способности делать определенные вещи на языке программирования. Я называю эти архетипы ограниченным и неограниченным.

## Ограниченные каркасы

В .NET к ограниченным относятся каркасы Rhino Mocks , Moq , NMock ,
EasyMock , NSubstitute и FakeItEasy , в Java – jMock и EasyMock.
Я называю их ограниченными, потому что есть такие вещи, которые
они неспособны подделать. Что именно каркас не может подделать,
зависит от того, на какой платформе он работает и как ее использует.
В .NET ограниченные каркасы не умеют подделывать статические
методы, невиртуальные методы, неоткрытые методы и т. д.
Почему так? Ограниченный изолирующий каркас работает так
же, как рукописная подделка: генерирует код и компилирует его во
время выполнения, поэтому он не может сделать больше того, что
позволяет компилятор и промежуточный язык . В Java компилятор
и результирующий байт-код эквивалентны. В C++ ограничения
налагаются возможностями языка.
Ограниченный каркас обычно генерирует во время выполнения
классы, наследующие или переопределяющие методы интерфейсов
или базовых классов, – так же, как мы сами; только мы это делаем до
выполнения программы, а каркасы – во время выполнения. Это означает, что каркас связан теми же ограничениями, налагаемыми компилятором: подделываемый код должен быть либо интерфейсом, либо
открытым и допускающим наследование (незапечатанным) классом
с открытым конструктором. В случае базовых классов переопределяемые методы должны быть виртуальными.
Все это означает, что при работе с ограниченными каркасами мы
связаны такими же правилами компилятора, как и обычный код. Статические методы, закрытые методы, запечатанные классы, классы с
закрытыми конструкторами и прочее в том же роде – все это нам не
подделать.

## Неограниченные каркасы

В .NET к неограниченным относятся каркасы Typemock Isolator,
JustMock и Moles (известный также под названием MS Fakes ), в
Java – PowerMock и JMockit , в C++ – Isolator++ и Hippo Mocks .
Неограниченные каркасы не генерируют и не компилируют во время
выполнения код, наследующий каким-то классам. Они применяют
для достижения цели совсем другие средства – какие именно, зависит
от платформы.
Прежде чем объяснять, как это работает в .NET, хочу предупредить, что в этой главе мы копнем довольно глубоко. К автономному тестированию излагаемый материал не имеет прямого отношения,
но позволит вам понять, почему некоторые вещи устроены именно
так, а не иначе, и на базе этих знаний принимать обоснованные решения о проектировании автономных тестов и выбирать курс действий.
В .NET все неограниченные каркасы построены на основе профилировщика. Это означает, что они пользуются рядом неуправляемых
API профилирования, которые обертывают работающий экземпляр
CLR (общеязыковой среды выполнения). Прочитать об этом можно на странице http://msdn.microsoft.com/en-us/library/bb384493.
aspx#profiling_api. API профилирования включает события, извещающие обо всем, что происходит, когда CLR выполняет код, и даже о
том, что случается, до того как промежуточный код .NET (IL) компилируется в двоичный в памяти. Некоторые из этих событий позволяют вставить новый или изменить существующий IL-код перед
компиляцией, т. е. расширить функциональные возможности существующего кода. Многие инструменты, от профилировщика ANTS
до профилировщиков памяти, пользуются API профилирования.
Typemock Isolator стал первым каркасом (больше семи лет назад),
авторы которого осознали потенциал API профилирования в части
изменения поведения «поддельных» объектов.
Поскольку события профилирования генерируются для всех частей кода, в том числе статических методов, закрытых конструкторов и
даже не принадлежащего вам стороннего кода, например SharePoint,
неограниченный каркас может расширить или изменить поведение
любого кода, какой пожелает, – в любом классе, в любой библиотеке,
в том числе и той, которую вы не компилировали. Возможности безграничны. Более подробно я рассматриваю различия между каркасами на основе профилировщика в приложении.
В .NET, для того чтобы включить профилирование и прогнать тесты, написанные для каркаса на основе профилировщика, необходимо
задать некоторые переменные окружения, читаемые исполняемым
процессом. По умолчанию они не заданы, поэтому код не профилируется. Чтобы подключить профилировщик к процессу прогона тестов,
задайте Cor_Enable_Pro%ling=0x1 и COR_PROFILER=46~0x1_GUID (да,
в каждый момент времени присоединить можно только один профилировщик).
Для каркасов Moles, Typemock и JustMock имеются специальные
надстройки над Visual Studio, которые задают эти переменные окружения и позволяют прогонять тесты. Обычно к таким инструментам прилагается специальная консольная программа, которая запускает
другие программы, предварительно установив эти переменные.
Если вы попытаетесь прогнать тесты, не включив профилировщик,
то исполнитель тестов будет выводить странные сообщения об ошибках в окно вывода. Я вас предупредил. Изолирующий каркас может,
например, сообщить, что ничего не записано или что ни один тест не
выполнен.
У неограниченных изолирующих каркасов есть ряд преимуществ.
- Мы можем написать автономные тесты для кода, который
раньше было невозможно протестировать; нужно лишь подделать все окружение единицы работы, изолировав ее; как-то
изменять код при этом не придется. Позже, уже имея тесты,
можно будет заняться рефакторингом.
- Можно подделать сторонние системы, которые мы не контролируем и которые серьезно осложняют тестирование, например, если наши классы наследуют базовому классу, который
находится в сторонней библиотеке и имеет много низкоуровневых зависимостей (к таковым относятся, к примеру,
SharePoint, CRM, Entity Framework и Silverlight).
- Можно выбрать собственный уровень проектирования, не
связывая себя по рукам и ногам конкретными паттернами. Дизайн создают не инструменты, а люди. Если вы не понимаете,
что делаете, никакой инструмент не поможет. Я еще вернусь к
этому вопросу в главе 11.

Но у неограниченных изолирующих каркасов есть и недостатки.
- Если вы недостаточно аккуратны, то можете загнать себя в
угол, подделывая всякие ненужные вещи, вместо того чтобы
поискать истинную единицу работы на более высоком уровне.
- При небрежной работе некоторые тесты могут стать несопровождаемыми, потому что вы подделали API, которыми не
владеете. Такое случается, но не так часто, как вы думаете.
Судя по моему опыту, крайне маловероятно, что подделанный
в каркасе низкоуровневый API изменится в будущем. Чем
глубже API, тем больше уровней над ним надстроено и тем
маловероятнее, что кто-то рискнет его изменить.

Далее мы рассмотрим механизмы, которые дают неограниченным
каркасам возможность совершать эти невероятные подвиги.

## Как работают неограниченные каркасы на основе профилировщика

Этот раздел относится только к платформе .NET и CLR, потому что
лишь там имеется API профилирования. Излагаемый материал будет
интересен только читателям, которые хотят знать о мельчайших деталях. Для создания хороших автономных тестов это необязательно, но
даст дополнительные очки, если вы когда-нибудь захотите написать
конкурирующий каркас. В Java и в C++ для достижения аналогичных
целей применяются совсем другие способы.
В .NET в инструментах типа Typemock Isolator имеется написанный на C++ код, который подключается к COM-интерфейсу API профилирования в CLR и подписывается на обратные вызовы, относящиеся к различным специальным событиям. Typemock даже владеет
патентом на эту технологию (см. http://bit.ly/typemockpatent), Правда, компания, похоже, не требует его неукоснительного соблюдения,
иначе не было бы конкурентов в лице JustMock и Moles.
События JitCompilationStarted и SetILFunctionBody , являющиеся членами COM-интерфейса ICorPro%lerCallback2 , позволяют
во время выполнения получать и изменять подлежащий исполнению
IL-код еще до его компиляции в двоичный. Этот IL-код можно подменить своим собственным. Typemock и подобные ему инструменты
добавляют IL-вставки до и после каждого метода, до которого могут
дотянуться. По сути дела, эти вставки обращаются к управляемому
коду на C# и проверяют, установил ли кто-то специальное поведение
для данного метода. Можно рассматривать эту процедуру как глобальную аспектно-ориентированную сквозную проверку поведения
всех методов в вашем коде. Внедренные IL-вставки обращаются также к различным точкам подключения (написанным на управляемом
языке, как правило на C#, и находящимся в самом сердце изолирующего каркаса) – к каким именно, зависит от поведения, установленного пользователем API каркаса (например, «возбудить исключение»
или «вернуть поддельное значение»).
В .NET любой код подвергается JIT-компиляции (если только не
был предварительно откомпилирован в машинный код с помощью
NGen.exe). Это относится не только к вашему, но и к чужому коду, в
том числе коду самого каркаса .NET Framework, SharePoint и других
библиотек.
Это означает, что Typemock может внедрить IL-код куда захочет,
даже внутрь .NET Framework. Вставки можно поместить до или после любого метода, в том числе написанного не вами, именно поэтому
такие каркасы – дар господний для тестирования унаследованного
кода, который вы не можете переработать.

**Примечание**. API профилирования не очень хорошо документирован
(специально?). Но если поискать в Google JitCompilationStarted и
SetILFunctionBody, то вы найдете много ссылок и историй, которые могут
стать путеводной нитью при построении собственного неограниченного изолирующего каркаса для .NET. Приготовьтесь к долгому и трудному путешествию и изучайте C++. Не забудьте взять в дорогу бутылочку виски.

## Разные каркасы задействуют разные возможности профилировщика

В принципе, всем изолирующим каркасам на основе профилировщика доступны одни и те же базовые возможности. Но на практике
функциональность основных каркасов в .NET различается. В каждом
из каркасов большой тройки – JustMock, Typemock и MS Fakes –
реализовано некоторое подмножество функций.

**Примечание**. Я употребляю названия Typemock и Typemock Isolator как синонимы, потому что так принято называть продукт Isolator.

Typemock, имея самую долгую историю, поддерживает почти все
конструкции, которые могли бы показаться нетестопригодными в
унаследованном коде, в том числе будущие значения, статические
конструкторы и прочие странные создания. Не умеет он только подделывать API из библиотеки mscorlib.dll, где находятся такие важнейшие классы, как DateTime, и пространства имен System.String и
System.IO. Для этой конкретной DLL (и только для нее) Typemock
поддерживает не все API, а только часть.
Технически Typemock мог бы подделать и все типы из этой библиотеки, но это бессмысленно по соображениям производительности.
Представьте, что вы захотели подменить все строки в системе, возвращая вместо них поддельные значения. Примите во внимание, сколько раз каждая строка используется в базовом API .NET Framework,
и помножьте это число на одну-две проверки на каждое обращение
внутри Typemock, необходимые, чтобы понять, нужно подделывать
данное действие или нет, – и вы поймете, что с производительностью
можно распроститься.
За исключением некоторых базовых типов .NET Framework,
Typemock готов подделать практически все, что вы ему подбросите.
У каркаса MS Fakes есть одно преимущество над Typemock Isolator.
Он разработан внутри Microsoft, первоначально как дополнение к
другому инструменту – Pex (описан в приложении). Понятно, что
сотрудники Microsoft лучше осведомлены обо всех тонкостях плохо
документированного API профилирования, поэтому встроили поддержку некоторых типов, которые даже Typemock Isolator не позволяет подделать. С другой стороны, API каркаса MS Fakes не содержит
большинства средств для работы с унаследованным кодом, которые
имеются в Isolator или JustMock и которых было бы естественно ожидать от каркаса с такими возможностями. Этот API в основном разрешает подменять открытые методы (статические и нестатические)
собственными делегатами, но без дополнительных надстроек не позволяет подделывать неоткрытые методы.
С точки зрения API и того, что можно подделывать, JustMock по
своим возможностям очень близок к Typemock Isolator, но пока ему
недостает некоторых средств, нужных при работе с унаследованным
кодом, в том числе возможности подделывать статические конструкторы и закрытые методы. Объясняется это, главным образом, недостаточной зрелостью. MS Fakes и JustMock существуют всего-то года
три. Typemock опережает их на 3–4 года.
Пока важно уяснить, что выбирая изолирующий каркас, вы вместе
с ним выбираете и набор возможностей или ограничений.

**Примечание**. За использование каркасов на основе профилировщиков приходится расплачиваться некоторой потерей производительности. Поскольку
при вызове каждого метода добавляются обращения к написанному вами
коду, то работа замедляется. Возможно, вы начнете это замечать, только
когда число тестов перевалит за несколько сотен, но замедление есть, и его
нельзя назвать пренебрежимо малым. Впрочем, я считаю это небольшой ценой за те огромные выгоды, которые такие каркасы дают при подделывании
и тестировании унаследованного кода.

## Полезные качества хороших изолирующих каркасов

В .NET (и отчасти в Java) в последние два года стало подрастать новое
поколение изолирующих каркасов. Они избавились от лишнего веса,
присущего старым заслуженным каркасам, и сделали гигантский рывок в плане удобочитаемости, удобства работы и простоты. Самое
главное, что они теперь поддерживают стабильность тестов благодаря особенностям, о которых я расскажу чуть ниже.
К числу этих новых каркасов относятся Typemock Isolator (хотя
он-то как раз не первой молодости), NSubstitute и FakeItEasy . Первый из них неограниченный, два других ограниченные, но, несмотря
на ограничения, обладают рядом интересных возможностей.
К сожалению, в таких языках, как Ruby, Python, JavaScript и другие, изолирующие каркасы все еще отстают по части удобочитаемости и удобства пользования. Возможно, дело в недостаточной зрелости
самих каркасов, а, возможно, в том, что культура автономного тестирования в этих языках еще не достигла таких высот, как на платформе
.NET. А может быть и так, что мы все неправы, а идти надо тем путем,
который применяется для изоляции в Ruby. Да, так о чем это я?
Хороший изолирующий каркас должен обладать двумя важными
полезными качествами:
- неустареваемость;
- удобство пользования.

Вот перечень некоторых особенностей новых каркасов, благодаря
которым они этими качествами обладают:

- рекурсивные подделки;
- игнорирование аргументов по умолчанию;
- массовое подделывание;
- нестрогое поведение подделок;
- нестрогие подставки.

## Особенности, обеспечивающие неустареваемость и удобство пользования

Неустаревающий тест перестает проходить только при наличии основательных причин, связанных с существенным изменением продуктового кода. Удобство пользования – это качество, благодаря которому каркас легко понять и применять. Изолирующие каркасы – такая
штука, которую проще простого использовать плохо, что приводит к
очень хрупким и не защищенным от будущих изменений тестам.
Перечислю особенности, способствующие повышению стабильности тестов:
- рекурсивные подделки;
- игнорирование по умолчанию аргументов для поведений и
проверок;
- нестрогие проверки и поведение;
- массовое подделывание.

## Рекурсивные подделки

Рекурсивное подделывание – это специальное поведение поддельных
объектов в случае, когда их методы возвращают другие объекты. Эти
объекты автоматически становятся подделками. Любые объекты, возвращенные любым методом такого автоматически подделанного объекта, также будут поддельными. То есть налицо рекурсия. Например:

```C#
public interface IPerson
{
 IPerson GetManager();
}
[Test]
public void RecursiveFakes_work()
{
 IPerson p = Substitute.For<IPerson>();
 Assert.IsNotNull(p.GetManager());
 Assert.IsNotNull(p.GetManager().GetManager());
 Assert.IsNotNull(p.GetManager().GetManager().GetManager());
}
```


Обратите внимание, что для получения такого поведения мы ничего специально не делали. Почему эта возможность так важна? Чем
меньше на стадии подготовки теста нужно сообщать о том, какие
конкретно API подделывать, тем слабее тест связан с фактической
реализацией продуктового кода и тем менее вероятно, что придется
изменять тест, если в будущем изменится продуктовый код.
Не все изолирующие каркасы поддерживают рекурсивное подделывание, потому обращайте на это внимание при выборе. Насколько
я знаю, пока такая возможность реализована только на платформе
.NET, и очень хотелось бы увидеть ее в каркасах для других языков.
Отметим также, что ограниченные каркасы в .NET способны поддержать рекурсивные подделки только для методов, которые можно
переопределить в сгенерированном коде, т. е. открытых виртуальных
методов или методов, объявленных в интерфейсе.
Некоторые опасаются, что такая возможность позволяет легко нарушить закон Деметры (http://en.wikipedia.org/wiki/Law_of_Demeter).
Я с этим не согласен, потому что хороший проект не навязывается
инструментами, а создается людьми, которые общаются между собой, учатся друг у друга и парами проводят критический анализ кода. Но о
проектировании у нас будет время поговорить в главе 11.

## Игнорирование аргументов по умолчанию

В настоящее время во всех каркасах, кроме Typemock Isolator, значения
аргументов, переданные API изменения поведения или проверки,
используются как ожидаемые значения по умолчанию. Isolator по
умолчанию игнорирует переданные вами значения, если только явно
не сказать (с помощью вызова API), что значения аргументов важны.
Отпадает необходимость включать Arg.IsAny<Type> во все методы,
что сокращает размер теста и позволяет обойтись без обобщенных
методов, которые только затрудняют чтение. В Typemock Isolator,
чтобы возбудить исключение при любых аргументах, нужно просто
написать:

```C#
Isolate.WhenCalled(() => stubLogger.Write(“”))
 .WillThrow(new Exception(“Fake”));
```

## Массовое подделывание

Под массовым подделыванием (wide faking) понимается возможность подделывать сразу несколько методов. В каком-то смысле рекурсивное подделывание – частный случай этой идеи, но существуют и другие реализации.
 Например, FakeItEasy позволяет сказать, что все методы некоторого объекта должны возвращать одно и то же значение. Или что это
распространяется только на методы, возвращающие значения определенного типа:

```C#
A.CallTo(foo).Throws(new Exception());
A.CallTo(foo).WithReturnType<string>().Returns(“hello world”);

```

В Typemock можно сказать, что по умолчанию все статические методы некоторого типа должны возвращать поддельное значение:

```C#
Isolate.Fake.StaticMethods(typeof(HttpRuntime));
```

Начиная с этого момента, любой статический метод объекта типа
HttpRuntime будет возвращать поддельное значение, зависящее от
типа, или – если он возвращает объект – рекурсивную подделку.
Я считаю, что это очень важно для обеспечения неустареваемости
тестов в случае развития продуктового кода. Метод, добавленный в продуктовый код через шесть месяцев после написания теста, будет
автоматически подделываться всеми существующими тестами, которым, следовательно, появление нового метода безразлично.

## Нестрогое поведение подделок

Мир изолирующих каркасов был и по большей части остается весьма
строгим. Многие каркасы для платформ, отличных от .NET (например, для Java и Ruby), по умолчанию строгие, тогда как каркасы для
.NET уже перешагнули этот этап.
Методы строгой подделки будут успешно вызваны, только если
указать с помощью API, что они «ожидаемые». Эта возможность ожидать вызова метода поддельного объекта отсутствует в NSubstitute (и
в FakeItEasy), но существует во многих других каркасах для .NET и
других языков (Moq , Rhino Mocks и старый API каркаса Typemock
Isolator).
Если метод помечен как ожидаемый, то любое обращение, отличное от ожидаемого (например, я ожидаю, что в начале теста метод
LogError будет вызван с параметром a), – либо из-за различий в значениях параметров, либо из-за имени метода – обычно заканчивается
исключением.
Тест обычно отказывает при первом неожиданном вызове метода
строгой подставки. Я говорю обычно, потому что подставка может
возбуждать или не возбуждать исключение в зависимости от реализации изолирующего каркаса. Некоторые каркасы позволяют отложить
возбуждение всех исключений до вызова verify() в конце теста.
Почему многие каркасы устроены именно так, можно прочитать в
книге Freeman, Pryce «Growing Object-Oriented Software, Guided by
Tests» (Addison-Wesley Professional, 2009). Авторы используют утверждения относительно подставок для описания «протокола» взаимодействия объектов. Поскольку протокол обязан быть строгим, то
чтение теста должно помогать в понимании того, какие способы взаимодействия с объектом допустимы.
И в чем тут проблема? Дело не в самой идее, а в том, с какой легкостью эту возможность можно употребить во вред.
Строгая подставка может отказывать в двух случаях: если вызывается неожиданный метод или если не вызываются ожидаемые (что
определяется при обращении к Received()).
Меня волнует первый случай. В предположении, что мне безразличны внутренние протоколы общения объектов внутри моей единицы работы, я не должен высказывать никаких утверждений об их
взаимодействиях, если не хочу попасть в весьма затруднительное положение. Тест может отказать, если я решу вызвать метод какого-то
внутреннего для единицы работы объекта. И хотя он никак связан с
ее конечным результатом, тест все равно хнычет: «Ты мне не говорил,
что кто-то собирается вызывать тот метод».

## Нестрогие подставки

Как правило, при использовании нестрогих подставок тесты получаются менее хрупкими. Нестрогий подставной объект позволяет
вызывать любые свои методы, даже неожиданные. Если метод возвращает значение, то подставка вернет значение по умолчанию либо
null, если требуется вернуть объект. В более развитых каркасах есть
даже понятие рекурсивных подделок – если у поддельного объекта
имеется метод, возвращающий объект, то по умолчанию будет возвращен поддельный объект соответствующего типа. И этот объект
также – рекурсивно – будет возвращать поддельные объекты из методов, возвращающих объекты. (Такая функция имеется в Typemock
Isolator, NSub, Moq и частично в Rhino Mocks.)
В листинге 5.3 из главы 5 приведен незамутненный пример нестрогой подставки. Нам безразлично, какие еще методы вызывались.
В листинге 5.4 и следующем за ним фрагменте показано, как можно
сделать тест более стабильным и неустаревающим, воспользовавшись
сопоставителем аргументов вместо полной строки. Сопоставление
аргументов позволяет создавать правила, описывающие, как следует передавать поддельному объекту параметры, чтобы тот считал их
правильными. Но обратите внимание, как это уродует тестовый код.

## Антипаттерны проектирования в изолирующих каркасах

Приведу перечень некоторых имеющихся в современных каркасах
антипаттернов, которые можно без труда сгладить:

- смешение понятий;
- запись и воспроизведение;
- липкое поведение;
- сложный синтаксис.

Рассмотрим их поочередно.

## Смешение понятий

 Смешение понятий я называю передозировкой подставок. Я предпочитаю каркасы, в которых слово «подставка» (mock) вообще не употребляется.
 Мы должны знать, сколько в тесте используется заглушек и сколько подставок, потому что наличие более одной подставки обычно
свидетельствует о проблеме. Если каркас не различает то и другое, то
он может назвать нечто подставкой, хотя на самом деле оно используется как заглушка. У нас уйдет время на то, чтобы понять, есть тут
проблема или нет, а, значит, удобочитаемость пострадает.
Вот пример из Moq:

```C#
[Test]
public void ctor_WhenViewhasError_CallsLogger()
{
 var view = new Mock<IView>();
 var logger = new Mock<ILogger>();
 Presenter p = new Presenter(view.Object, logger.Object);
 view.Raise(v => v.ErrorOccured += null, “fake error”);
 logger.Verify(log =>
 log.LogError(It.Is<string>(s=> s.Contains(“fake error”))));
}
```

Вот как можно избежать смешения понятий.
- Использовать в API специальные слова для подставки и заглушки. Так сделано, например, в Rhino Mocks.
- Вообще не употреблять термины подставка и заглушка в
API, а использовать общее обозначение для любого поддельного объекта. Например, в FakeItEasy нет ничего, кроме Fake<Something>. Подставки и заглушки отсутствуют
как класс. В NSubstitute , как вы помните, имеется лишь
Substitute<Something>. В Typemock Isolator вызывается
Isolate.Fake.Instance<Something>. Подставка и заглушка
нигде не упоминаются.
- Если вы пользуетесь изолирующим каркасом, который не различает заглушки и подставки, то хотя бы называйте переменные по принципу mockXXX и stubXXX, чтобы как-то сгладить
проблемы с удобочитаемостью.

Если вообще отказаться от перегруженного термина или дать пользователю возможность указать, что именно он создает, то тесты станут понятнее. Или, по крайней мере, будет меньше путаницы в терминологии.
Вот тот же тест, что и выше, только переменные названы в соответствии со способом использования. Так ведь читается лучше, правда?

```C#
[Test]
public void ctor_WhenViewhasError_CallsLogger()
{
 var stubView = new Mock<IView>();
 var mockLogger = new Mock<ILogger>();
 Presenter p = new Presenter(stubView.Object, mockLogger.Object);
 stubView.Raise(view => view.ErrorOccured += null, “fake error”);
 mockLogger.Verify(logger =>
 logger.LogError(It.Is<string>(s=>s.Contains(“fake error”))));
}
```

## Запись и воспроизведение

Изолирующие каркасы, основанные на записи и воспроизведении,
порождали неудобочитаемые тесты. Верный признак неудобочитаемости – необходимость несколько раз пробегать текст глазами, чтобы
понять, что он означает. Обычно это наблюдается в коде, написанном
с применением каркаса, поддерживающего API записи и воспроизведения.
Возьмем пример использования Rhino Mocks (который поддерживает запись и воспроизведения) из блога Расмуса Кроманн-Ларсена
по адресу http://rasmuskl.dk/post/Why-AAA-style-mockingis-betterthan-Record-Playback.aspx (не пытайтесь его компилировать, это всего лишь пример).

```C#
[Test]
public void ShouldIgnoreRespondentsThatDoesNotExistRecordPlayback()
{
 // 

 var guid = Guid.NewGuid();
 // 

 IEventRaiser executeRaiser;
 using(_mocks.Record())
 {
 // 
 (?)
 Expect.Call(_view.Respondents).Return(new[] {guid.ToString()});
 Expect.Call(_repository.GetById(guid)).Return(null);
 // 


view.ExecuteOperation += null;
 executeRaiser = LastCall.IgnoreArguments()
 .Repeat.Any()
 .GetEventRaiser();
 // 
 Expect.Call(_view.OperationErrors = null)
 .IgnoreArguments()
 .Constraints(List.IsIn(“Non-existant respondent: “ + guid));
 }
 using(_mocks.Playback())
 {
 //

 new BulkRespondentPresenter(_view, _repository);
 //
 executeRaiser.Raise(null, EventArgs.Empty);
 }
}


```

А вот тот же самый код в каркасе Moq (который поддерживает
стиль подготовка-действие-утверждение).

```C#
[Test]
public void ShouldIgnoreRespondentsThatDoesNotExist()
{
 //

 var guid = Guid.NewGuid();
 _viewMock.Setup(x => x.Respondents).Returns(new[] { guid.ToString() });
 _repositoryMock.Setup(x => x.GetById(guid)).Returns(() => null);
 // 
 _viewMock.Raise(x => x.ExecuteOperation += null, EventArgs.Empty);
 //
 _viewMock.VerifySet(x => x.OperationErrors =
 It.Is<IList<string>>(l=>l.Contains(“Non-existant respondent: “+guid)));
}
```
Не правда ли, разница гигантская и не в пользу записи и воспроизведения?

## Липкое поведение

Если вы один раз сказали, что поддельный метод должен при вызове
вести себя определенным образом, то что произойдет, когда он будет
вызван в продуктовом коде в следующий раз? Или следующие 100 раз? Должно ли тесту быть до этого дело? Если задумано так, что
поддельное поведение методов проявляется только один раз, то тест
должен давать ответ на вопрос «что делать дальше?» всякий раз, как
в продуктовый код вносятся изменения, приводящие к вызову поддельного метода, даже если тесту нет дела до этих дополнительных
вызовов. Теперь тест более тесно связан с внутренними деталями реализации.
Для решения этой проблемы изолирующий каркас может сделать
поведение «липким». Однажды сказав, что метод должен вести себя
определенным образом (например, возвращать false), мы можем
рассчитывать, что он будет себя так, до тех пор пока не получит иное
указание (все последующие вызовы будут возвращать false, хоть
100 раз метод вызывай). Это освобождает тест от необходимости
знать, как метод должен вести себя в дальнейшем, когда это уже несущественно для теста.

## Сложный синтаксис

В некоторых каркасах трудно запомнить, как выполняются стандартные операции, даже если вы это уже несколько раз делали. Это
мешает кодированию. API должен легко запоминаться. Например, в
FakeItEasy все допустимые операции обязаны начинаться с прописной буквы A. Вот пример, взятый с вики-сайта FakeItEasy по адресу
https://github.com/FakeItEasy/FakeItEasy/wiki:

```C#
var lollipop = A.Fake<ICandy>();
var shop = A.Fake<ICandyShop>();
// 4
:
A.CallTo(() => shop.GetTopSellingCandy()).Returns(lollipop);
A.CallTo(() => foo.Bar(A<string>.Ignored,
 “second argument”)).Throws(new Exception());
// 
.
var developer = new SweetTooth();
developer.BuyTastiestCandy(shop);
// $
// 
A.CallTo(() => shop.BuyCandy(lollipop)).MustHaveHappened();

```

Та же идея применяется в Typemock Isolator , где все вызовы API
начинаются словом Isolate.
Наличие единственной точки входа позволяет правильно начать
слово, а затем с помощью встроенного в IDE механизма Intellisense
решить, что писать дальше.
В NSubstitute нужно запомнить, что для создания подделок служит метод Substitute, что нужно использовать методы расширения
реальных объектов для проверки или изменения поведения и что
Arg<T> используется в сопоставителях аргументов.

## Выводы

Изолирующие каркасы делятся на две категории: ограниченные и
неограниченные. В зависимости от платформы возможностей может
быть больше или меньше, поэтому, выбирая каркас, важно понимать,
что он умеет, а чего не умеет делать.
В .NET неограниченные каркасы построены на основе API профилирования, тогда как большинство ограниченных генерируют и компилируют код во время выполнения – точно так же, как поступаем мы
сами, когда пишем заглушки и подставки вручную.
Изолирующие каркасы, которые поддерживают неустареваемость
и удобство пользования, могут облегчить вашу жизнь в стране автономных тестов, а те, что не поддерживают, – осложнят ее.
Вот и все! Мы рассмотрели основные приемы написания автономных тестов. В третьей части книги мы займемся управлением кодом
тестов, организацией тестов и паттернами, которые приводят к созданию надежных, легко сопровождаемых и понятных тестов.


