# Работа с унаследованным кодом

В этой главе:
 - Типичные проблемы унаследованного кода.
 - С чего начинать написание тестов.
 - Обзор полезных инструментов для работы с унаследованным кодом.

Как-то мне довелось консультировать крупную компанию, которая
изготавливала ПО для выставления счетов. В компании работало
более 10 000 разработчиков, которые писали на смеси .NET, Java и
C++. Были там и продукты, и субпродукты и переплетенные проекты. В той или иной форме программа существовала свыше пяти лет,
и большая часть разработчиков занималась сопровождением и надстройками над существующей функциональностью.
В мою задачу входило оказание помощи нескольким подразделениям (в которых использовались все языки) в освоении методики
TDD. Примерно 90 % программистов, с которыми я работал, так и не
перешли на TDD по разным причинам, часть из которых была связана с унаследованным кодом:

- было трудно писать тесты для проверки существующего кода;
- было почти невозможно переработать существующий код (или
на это не хватало времени);
- некоторые не хотели менять структуру кода;
- мешал инструментарий (или его отсутствие);
- было трудно понять, с чего начать.

Всякий, кто хоть раз пытался добавить тесты в существующую
систему, понимает, что для большинства таких систем написать тесты
почти невозможно. Обычно при их разработке никто не думал о местах (зазорах), в которые можно было бы вставить расширения или
другие компоненты взамен существующих.
Имея дело с унаследованным кодом, нужно разрешить несколько
проблем.
- Работы уйма, с чего начинать тестирование? На чем сосредоточить усилия?
- Как можно безопасно подвергать код рефакторингу, если никаких тестов еще нет?
- Какие существуют инструменты для работы с унаследованным кодом?

В этой главе мы постараемся ответить на эти трудные вопросы: перечислим технические приемы, а также приведем ссылки на ресурсы
и инструменты.

## С чего начать добавление тестов?

В предположении, что существующий код находится внутри компонентов, нужно создать упорядоченный список компонентов, которые
полезнее всего протестировать. На место компонента в списке влияет
несколько факторов.

- Логическая сложность. Речь идет о количестве логических
конструкций в компоненте: вложенных if, предложений
switch, рекурсии. Для определения этой характеристики
можно использовать инструменты, вычисляющие цикломатическую сложность.

- Уровень зависимости. Под этим понимается количество других компонентов, от которых зависит данный. Сколько зависимостей придется разорвать, чтобы протестировать класс?
Быть может, он взаимодействует с внешним почтовым компонентом или вызывает какой-нибудь статический метод протоколирования?

- Приоритет. Это общий приоритет компонента в проекте.

Каждому компоненту можно назначить оценку по каждому из этих
факторов, от 1 (наименее важный) до 10 (наиболее важный).

В табл. 10.1 показано несколько классов с оценками указанных
факторов. Я называю ее таблицей целесообразности тестов.

Есть два основных способа
интерпретации этой диаграммы
с целью решить, что тестировать
сначала (см. рис. 10.2).
![test1](./images/test1.png)

- Выбирать логически сложные компоненты, которые
проще тестировать (левый
верхний квадрант).
- Выбирать логически сложные компоненты, которые
труднее тестировать (правый верхний квадрант).

Теперь возникает вопрос, по
какому пути идти. Начать с простого или с трудного?

## На какой стратегии выбора остановиться

В предыдущем разделе было сказано, что можно начать с компонентов, которые легко тестировать, или с тех, которые тестировать трудно (потому что у них много зависимостей). У каждой стратегии есть
свои проблемы.

### Плюсы и минусы стратегии «сначала простые»

Если начать с компонентов, у которых меньше зависимостей, то первые тесты можно будет написать легко и быстро. Но тут есть подвох,
изображенный на рис. 10.3.

![test2](./images/test2.png)

Если начинать с
простых компонентов, то время
создания тестов при переходе
к более трудным будет
возрастать

На рис. 10.3 показано, сколько
времени занимает подготовка компонентов к тестированию на протяжении срока жизни проекта. Поначалу тесты писать легко, но чем
дальше, тем труднее тестировать
каждый следующий компонент, а
самые трудные поджидают в конце
цикла, когда все уже с нетерпением
ждут выпуска продукта в мир.
Если команда еще не поднаторела в автономном тестировании, то
имеет смысл начинать с легких компонентов. Со временем команда освоит приемы, необходимые для
тестирования более трудных компонентов с большим числом зависимостей.
Такой команде лучше поначалу вообще избегать компонентов, для
которых число зависимостей больше определенного порога (я считаю
разумным порог 4).

## Плюсы и минусы стратегии «сначала трудные»

Предложение начинать с более трудных компонентов может показаться бессмысленным, но с точки зрения команды, имеющих богатый опыт автономного тестирования, у него есть достоинства.
На рис. 10.4 показано среднее
время написания теста одного компонента на протяжении срока жизни проекта в случае, когда сначала
тестируются компоненты с большим числом зависимостей.
При такой стратегии можно потратить целый день, а то и больше на
написание даже простейших тестов
для самых сложных компонентов.
Но обратите внимание, как быстро спадает время создания одного
теста по сравнению с медленным
ростом на рис. 10.3.

![test3](./images/test3.png)
Если начинать
с трудных компонентов, то
время создания тестов поначалу
велико, но уменьшается по мере
устранения зависимостей
в ходе рефакторинга

Тестируя очередной компонент и перерабатывая его, чтобы сделать более тестопригодным, вы заодно решаете проблемы зависимостей, встречающихся в нем и в других компонентах. Точнее, рефакторинг компонента
с большим числом зависимостей может улучшить положение дел в
других частях системы. Отсюда и быстрый спад.
Стратегия «сначала трудные» применима, только если команда имеет достаточный опыт автономного тестирования, потому что реализовать ее сложнее. Если такой опыт есть, ориентируйтесь на приоритет
компонентов, решая, с каких – трудных или легких – начать. Можно
выбрать и комбинированную стратегию, но важно заранее понимать,
сколько потребуется усилий и каковы возможные последствия.

## Написание интеграционных тестов до рефакторинга

 Если вы таки планируете переработать код, сделав его тестопригодным (чтобы можно было писать автономные тесты), то реальный способ гарантировать, что в ходе рефакторинга ничего не сломается, –
написать интеграционные тесты для работающей системы.
Я был консультантом в крупном унаследованном проекте и работал с программистом, которому был поручен менеджер конфигурации
на базе XML-файлов. Тестов в проекте не было, и тестопригодным
его можно было назвать с большим трудом. Проект к тому же был
написан на C++, поэтому мы не могли воспользоваться инструментом
типа Typemock Isolator для изоляции компонентов без рефакторинга
кода.
Программист должен был добавить в XML-файл еще одну пару
атрибут–значение и обеспечить чтение и изменение значения с помощью имеющегося компонента конфигурации. В конце концов мы
написали два интеграционных теста, которые пользовались реальной
системой для сохранения и загрузки конфигурационных данных и
содержали утверждения относительно значений, которые компонент
читал и записывал. Эти тесты определили «исходное» поведение менеджера конфигурации, от которого мы могли плясать.
Затем мы написали интеграционный тест, который показывал, что
сразу после чтения файла компонентом в памяти не было атрибута,
который мы собирались добавить. Мы доказали, что эта функциональность действительно раньше отсутствовала, и получили тест,
который должен был бы пройти, после того как мы добавим новый
атрибут в XML-файл и корректно запишем файл из компонента.

Написав код, который сохранял и загружал дополнительный атрибут, мы прогнали все три интеграционных теста (два первоначальных
и новый, который пытался читать новый атрибут). Все три прошли,
так что мы убедились, что, добавляя новую функциональность, ничего не сломали.

Как видите, процесс сравнительно прост:

- добавить один или несколько интеграционных тестов (никаких подставок и заглушек), доказывающих, что исходная система работает правильно;
- провести рефакторинг или добавить падающий тест для функциональности, которую вы собираетесь добавить в систему;
- проводить рефакторинг и понемногу вносить в систему изменения, как можно чаще прогоняя интеграционные тесты, которые проверяют, что ничего не сломалось.

Иногда может показаться, что интеграционные тесты писать проще, чем автономные, потому что не надо возиться с внедрением зависимостей. Но прогон таких тестов на локальной машине может
оказаться докучным и трудоемким делом, потому что необходимо
сконфигурировать систему, так чтобы все оказалось на своих местах.

Штука в том, чтобы работать только с теми частями системы, которые требуется исправить или дополнить. Не трогайте ничего другого.
Тогда система будет расти в нужных местах, и новые проблемы можно
будет решать по мере поступления.

Добавляя все новые и новые тесты, вы будете перерабатывать
систему, включать в нее автономные тесты, постепенно приводя ее к
удобному для сопровождения и тестопригодному виду. Это требует
времени (иногда много месяцев), но результат того стоит.

Я, помнится, говорил, что нужны хорошие инструменты. Познакомлю вас со своими любимыми.

## Инструменты, важные для автономного тестирования унаследованного кода

Ниже приводится несколько рекомендаций по поводу выбора инструментов, которые помогут приступить к тестированию существующего кода на платформе .NET.

- Изолируйте зависимости с помощью JustMock или Typemock
Isolator.
- Используйте JMockit при работе с унаследованным кодом на
Java.
- Используйте Vise для рефакторинга кода на Java.
- Используйте FitNesse для написания приемочных тестов перед началом рефакторинга.
- Прочитайте книгу Майкла Фэзерса об унаследованном коде.
- Используйте NDepend для исследования продуктового кода.
- Используйте ReSharper для навигации и рефакторинга продуктового кода.
- Используйте Simian и TeamCity для обнаружения повторяющегося кода (и ошибок).

Рассмотрим эти рекомендации более подробно.

## Изолируйте зависимости с помощью JustMock или Typemock Isolator

Неограниченные каркасы типа Typemock Isolator описывались в главе 6. Уникальная особенность таких каркасов, делающая их пригодными
для решения рассматриваемой задачи, – умение подделывать зависимости в имеющемся коде, вообще не подвергая его рефакторингу. Это
экономит время для начальной подготовки к тестированию, которого
всегда так не хватает.

# Почему Typemock, а не Microsoft Fakes?
Хотя каркас Microsoft Fakes бесплатен, а Isolator и JustMock – нет, я
полагаю, что использование Microsoft Fakes приведет к появлению в
проекте большого объема несопровождаемого кода, потому что дизайн
и особенности использования (генерация кода и разбросанные повсюду
делегаты) порождают очень хрупкий API, который трудно сопровождать. Эта
проблема даже отмечена в документе группы ALM Rangers, посвященном
Microsoft Fakes, который можно найти по адресу http://vsartesttoolingguide.
codeplex.com/releases/view/102290. Там говорится: «если вы подвергнете
рефакторингу тестируемый код, то автономные тесты, написанные с
помощью прокладок (Shims) и заглушек (Stubs) из прежних сборок Fakes,
компилироваться не будут. В настоящее время не существует простого решения этой проблемы за исключением разве что модификации тестов
с помощью специализированных регулярных выражений. Имейте это в
виду, оценивая затраты на рефакторинг кода, для которого существует
много автономных тестов. Затраты могут оказаться велики».

В следующих далее примерах я буду использовать Typemock Isolator,
потому что работать с ним мне наиболее комфортно. В Isolator (на момент написания этой книги последней была версия 7.0) используется
только термин fake, а слова mock и stub из API исключены. Этот каркас позволяет подделывать (fake) интерфейсы, запечатанные и статические типы, невиртуальные и статические методы. Это означает, что
вам не нужно думать об изменении проекта (для этого может не оказаться времени или возможности ввиду соображений безопасности).
Начинать тестирование можно почти сразу. Существует также бесплатная ограниченная версия Typemock, так что вы можете скачать
продукт и поэкспериментировать с ним. Только помните, что, будучи
ограниченной, эта версия работает лишь со стандартным тестопригодным кодом.
В листинге ниже приведены два примеры использования Isolator
API для подделывания экземпляров классом.

Листинг 10.1. Подделывание статических методов и создание
поддельных классов с помощью Isolator

```C#

[Test]
public void FakeAStaticMethod()
{
 Isolate
 .WhenCalled(()=>MyClass.SomeStaticMethod())
 .WillThrowException(new Exception());
}
[Test]
public void FakeAPrivateMethodOnAClassWithAPrivateConstructor()
{
 ClassWithPrivateConstructor c =
 Isolate.Fake.Instance<ClassWithPrivateConstructor>();
 Isolate.NonPublic.WhenCalled(c,”SomePrivateMethod”).WillReturn(3);
}

```

Как видите, API прост и понятен, для возврата поддельных значений в нем используются универсальные методы и делегаты. Существует также API, рассчитанный специально на VB.NET, в котором
синтаксис приближен к стилистике VB. Но в обоих случаях в дизайн
тестируемых классов не нужно вносить никаких изменений.

## Используйте JMockit при работе с унаследованным кодом на Java

JMockit и PowerMock – это проекты с открытым исходным кодом, в
которых для реализации некоторых вещей, которые Typemock Isolator
делает в .NET, используется Java Instrumentation API. Для изоляции
компонентов от зависимостей в существующий проект не нужно вносить никаких изменений.
В JMockit используется подход на основе подмены (swap). Сначала вручную пишется класс, которые должен будет заменить класс,
выс тупающей в роли зависимости для тестируемого компонента
(допустим, класс FakeDatabase призван заменить класс Database ).
Затем с помощью JMockit мы подменяем обращения к исходному
классу обращениями к нашему поддельному. Можно также переопределить методы класса, реализовав их в виде анонимных методов в тесте.
В следующем листинге приведен пример теста, в котором используется JMockit.

Листинг 10.2. Использование JMockit для подмены реализации класса

```C#

public class ServiceATest extends TestCase {
 private boolean serviceMethodCalled;
 public static class MockDatabase {
 static int %ndMethodCallCount;
 static int saveMethodCallCount;
 public static void save(Object o) {
 assertNotNull(o);
 saveMethodCallCount++;
 }
 public static List %nd(String ql, Object arg1) {
 assertNotNull(ql);
 assertNotNull(arg1);
 %ndMethodCallCount++;
 return Collections.EMPTY_LIST;
 }
 }
 protected void setUp() throws Exception {
 super.setUp();
 MockDatabase.%ndMethodCallCount = 0;
 MockDatabase.saveMethodCallCount = 0;

 Mockit.rede%neMethods(Database.class,
 MockDatabase.class);
 }
 public void testDoBusinessOperationXyz() throws Exception {
 %nal BigDecimal total = new BigDecimal(“125.40”);
 Mockit.rede%neMethods(ServiceB.class,
 new Object()
 {
 public BigDecimal computeTotal(List items)
 {
 assertNotNull(items);
 serviceMethodCalled = true;
 return total;
 }
 });
 EntityX data = new EntityX(5, “abc”, “5453-1”);
 new ServiceA().doBusinessOperationXyz(data);
 assertEquals(total, data.getTotal());
 assertTrue(serviceMethodCalled);
 assertEquals(1, MockDatabase.%ndMethodCallCount);
 assertEquals(1, MockDatabase.saveMethodCallCount);
 }
}
```

JMockit – неплохая отправная точка для тестирования унаследованного кода на Java.

## Используйте Vise для рефакторинга кода на Java

Майкл Фэзерс написал для Java интересный инструмент, который
позволяет убедиться, что по ходу рефакторинга не повреждаются
значения, которые могут изменяться в методе. Например, если метод
изменяет массив значений, то можно проверить, что в процессе рефакторинга никакое значение случайно не затирается.
В листинге ниже показано, как для этой цели применяется метод
Vise.grip().

Листинг 10.3. Использование Vise в программе на Java для проверки того,
что во время рефакторинга не изменились значения

```C#

import vise.tool.*;
public class RPRequest {
 ...

public int process(int level, RPPacket packet) {
 if (...) {
 if (...) {
 ...
 } else {
 ...
 bar_args[1] += list.size();
 Vise.grip(bar_args[1]);
 packet.add(new Subpacket(list, arrivalTime));
 if (packet.calcSize() > 2)
 bar_args[1] += 2;
 Vise.grip(bar_args[1]);
 }
 } else {
 int reqLine = -1;
 bar_args[0] = packet.calcSize(reqLine);
 Vise.grip(bar_args[0]);
 ...
 }
 }
}

```

Vise заставляет добавлять строки в рабочий код, и весь его смысл –
в поддержке рефакторинга. Для .NET такого инструмента не существует, но написать его сравнительно просто. При каждом вызове метод
Vise.grip() проверяет, что переданное ему значение по-прежнему
такое, каким должно быть. В некотором роде это добавление внутреннего утверждения с упрощенным синтаксисом. Vise может также
выдать отчет о «закрепленных» (gripped) переменных и их текущих
значениях.

## Используйте приемочные тесты перед началом рефакторинга

Очень разумно будет добавить интеграционные тесты перед началом рефакторинга кода. FitNesse – один из таких инструментов, он
позволяет создавать интеграционные и приемочные тесты. Из других подобных средств упомяну Cucumber и SpecFlow. (Для работы с
Cucumber нужно хотя бы немного знать язык Ruby. SpecFlow ориентирован на .NET и предназначен для разбора сценариев, написанных на Cucumber.) FitNesse позволяет писать интеграционные тесты приложения (на Java или .NET), а затем легко изменять их или добавлять
новые без необходимости писать код.

Использование каркаса FitNesse состоит из трех шагов.
1. Написать классы-адаптеры (они называются фикстурами),
которые обертывают продуктовый код и представляют действия пользователя, в которых этот код участвует. Например,
в банковском приложении можно было бы написать класс
bankingAdapter с методами withdraw и deposit.
2. Создать HTML-таблицы с помощью специального синтаксиса,
который понимает и разбирает движок FitNesse. В этих таблицах хранятся значения, которые будут использоваться во время прогона тестов. Таблицы размещаются на страницах специального вики-сайта, в основе которого лежит движок FitNesse,
поэтому ваш комплект тестов представляется внешнему миру
через сайт. Каждую страницу, содержащую таблицу (которая
видна в любом браузере), можно редактировать как обычную
страницу вики, и на каждой имеется кнопка Execute Tests
(Выполнить тесты). Таблицы разбираются во время выполнения и преобразуются в прогоны тестов.
3. Нажать кнопку Execute Tests на одной из вики-страниц. В результате движку FitNesse передаются параметры, заданные
в таблице. В конечном итоге движок вызывает ваши классы-обертки, которые обращаются к целевому приложению, и
высказывает утверждения о значениях, возвращенных этими
классами

На рис. 10.5 показан пример таблицы FitNesse в браузере. Подробнее узнать о каркасе FitNesse можно на сайте http://fitnesse.org/. Об
интеграции FitNesse с .NET написано на странице http://fitnesse.org/
FitNesse.DotNet.
Лично я всегда считал, что использование FitNesse – сплошная головная боль: и интерфейс неудобный, и в половине случаев вообще не
работает, особенно с кодом для .NET. Рекомендую вместо этого познакомиться с Cucumber на сайте http://cukes.info/.

## Используйте NDepend для исследования продуктового кода

NDepend – сравнительно новый коммерческий анализатор кода для
.NET, который умеет создавать наглядные представления различных
аспектов откомпилированных сборок, в том числе деревья зависимостей, сложность кода, отличия между разными версиями одной и
той же сборки и многое другое. Потенциал у этого инструмента огромный, я рекомендую научиться им пользоваться.
Самое мощное средство NDepend – это специальный язык запросов
(он называется CQL), на котором можно формулировать запросы о
структуре кода, получая в ответ различные метрики компонентов.
Например, нетрудно запросить все компоненты, в которых имеется
закрытый конструктор.
Купить NDepend можно на сайте www.ndepend.com.

## Используйте ReSharper для навигации и рефакторинга продуктового кода

ReSharper – одна из лучших надстроек над VS.NET для повышения
продуктивности. Помимо мощных автоматизированных средств рефакторинга (гораздо мощнее встроенных в Visual Studio 2008) этот
продукт знаменит своими навигационными возможностями. При работе с существующим проектом ReSharper может легко осуществлять
навигацию по коду с помощью комбинаций клавиш для перехода из
любой точки решения в любую другую, как-то связанную с исходной.

Приведем несколько примеров навигационных действий.
- Находясь в объявлении класса или метода, мы можем легко
перейти к любому наследнику класса или переопределенному
методу либо к реализации текущего члена в базовом классе,
если таковой существует.
- Можно найти все места, где используется данная переменная
(подсвечиваются в текущем редакторе).
- Можно найти все места, где используется общий интерфейс
или реализующий его класс.

Есть еще много комбинаций клавиш, которые позволяют с меньшими усилиями осуществлять навигацию по коду и исследовать его
структуру.

## Используйте Simian и TeamCity для обнаружения повторяющегося кода (и ошибок)

Допустим, вы нашли ошибку в своем коде и хотите удостовериться,
что больше нигде она не повторяется.
В программу TeamCity встроен обнаружитель дубликатов для
.NET. Дополнительные сведения о нем можно найти на странице
http://confluence.jetbrains.com/display/TCD6/Duplicates+Finder+
(.NET).

С помощью Simian легко найти повторяющийся код, узнать, сколько вам еще предстоит работы, а заодно произвести рефакторинг для устранения дублирования. Simian – коммерческий продукт, имеющий версии для .NET, Java, C++ и других языков. Купить его можно
на сайте www.harukizaemon.com/simian/.

## Выводы

В этой главе я рассказал о том, как подступиться к унаследованному
коду. Важно ранжировать компоненты по количеству зависимостей,
сложности логики и приоритету для проекта. Имея эту информацию,
вы сможете решить, с каких компонентов начать, исходя из легкости
(или трудности) их подготовки к тестированию.
Если у команды мало или совсем нет опыта автономного тестирования, то лучше начинать с легких компонентов, тогда по мере
добавления все новых и новых тестов уверенность команды в своих
силах будет возрастать. Опытной команде рекомендуется начинать
с трудных компонентов, тогда тестировать остальные части будет
проще.
Если команда не хочет производить рефакторинг кода, добиваясь
тестопригодности, а собирается просто написать автономные тесты
того, что есть, то будут полезны неограниченные изолирующие каркасы, потому что они позволяют изолировать зависимости, не изменяя существующий код. Подумайте об этом, если имеете дело с унаследованным кодом для .NET. При работе с Java обратите внимание на
JMockit или PowerMock – по тем же причинам.
Я также описал ряд инструментов, которые могут оказаться полезными в борьбе за улучшение качества существующего кода. Они
предназначены для разных этапов проекта, а решать, какой использовать (и использовать ли вообще), предстоит вашей команде.
И напоследок, как сказал один мой приятель, имея дело с унаследованным кодом, никогда не вредно запастись изрядной бутылкой
водочки.