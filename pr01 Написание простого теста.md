# Практическая работа 1. Написание простого теста

## Пример простого автономного теста

Автоматизированный автономный тест можно написать и без каркаса тестирования. На самом деле, с тех пор как у разработчиков стало
входить в привычку автоматизировать тестирование, я не раз видел,
как они это делают, не подозревая о существовании каркасов. В этой практической работе показано, как может выглядеть тест, созданный без использования каркаса.
Допустим, у нас есть класс ```SimpleParser``` и нам надо его протестировать. В классе есть метод ```ParseAndSum```, который принимает строку, состоящую из нуля или более чисел, разделенных запятыми. Если чисел в строке нет, метод возвращает 0. Если есть только одно число, оно возвращается в
виде int. Если чисел несколько, они складываются и возвращается
сумма (хотя в настоящий момент код умеет обрабатывать только
случаи нуля или одного числа). Да, я знаю, что ветвь else лишняя,
но из того, что ReSharper призывает вас спрыгнуть с моста, вовсе не
следует, что так и надо делать. На мой взгляд, else делает код более
удобочитаемым.

```C#
public class SimpleParser
{
 public int ParseAndSum(string numbers)
 {
 if(numbers.Length==0)
 {
 return 0;
 }
 if(!numbers.Contains(“,”))
 {
 return int.Parse(numbers);
 }
 else
 {
 throw new InvalidOperationException(
 “Пока умею обрабатывать только 0 и 1!”);
 }
 }
}

```

Можно создать проект простого консольного приложения,
которое ссылается на сборку с этим классом, и написать класс
```SimpleParserTests```, показанный в листинге ниже. Тестовый метод
вызывает метод продуктового класса (тестируемый) и проверяет возвращенное им значение. Если оно не совпадает с ожидаемым, тестовый метод выводит сообщение на консоль. Он также перехватывает
все исключения и тоже печатает их на консоли.

```C#
class SimpleParserTests
{
 public static void TestReturnsZeroWhenEmptyString()
 {
 try
 {
 SimpleParser p = new SimpleParser();
 int result = p.ParseAndSum(string.Empty);
 if(result!=0)
 {
 Console.WriteLine(
 @”***SimpleParserTests.TestReturnsZeroWhenEmptyString:
 -------
 ParseAndSum должен вернуть 0 для пустой строки”);
 }
}
 catch (Exception e)
 {
 Console.WriteLine(e);
 }
 }
}

```

Затем написанные тесты можно вызвать из выполняемого консольным приложением метода ```Main```, который показан в следующем листинге. Метод ```Main``` в данном случае играет роль простого
исполнителя тестов, который вызывает тесты один за другим, давая
им возможность выводить что-то на консоль. Поскольку приложение выполняемое, оно может работать без вмешательства человека
(при условии, что тесты не открывают интерактивных диалоговых
окон).


```C#
public static void Main(string[] args)
{
 try
 {
 SimpleParserTests.TestReturnsZeroWhenEmptyString();
 }
 catch (Exception e)
 {
 Console.WriteLine(e);
 }
}
```

Обязанность перехватывать исключения и выводить соответствующие сообщения на консоль (чтобы исключения не мешали выполнять последующие методы) возлагается на сами тестовые методы.
По мере увеличения количества тестов мы можем добавлять в Main
вызовы все новых и новых методов. Каждый тест отвечает за вывод
описания проблемы (если таковая имеется) на экран.

Понятно, что приведенный выше тест написан на скорую руку. Если
бы у нас было несколько подобных тестов, то, наверное, мы завели бы
общий метод ```ShowProblem``` , которым могли бы пользоваться все тесты
для единообразного форматирования сообщений об ошибках. Можно
было бы также добавить вспомогательные методы для проверки
объекта на null, обнаружения пустых строк и т. д. – чтобы не писать
одни и те же длинные строки в нескольких тестах.
В листинге ниже показано, как мог бы выглядеть этот тест при наличии чуть более общего метода ```ShowProblem```.

```C#
public class TestUtil
{
 public static void ShowProblem(string test,string message )
 {
 string msg = string.Format(@”
 ---{0}---
 {1}
 --------------------
 “, test, message);
 Console.WriteLine(msg);
 }
}
public static void TestReturnsZeroWhenEmptyString()
{

 // Используем API отражения в .NET для получения имени текущего метода.
 // Можно было бы зашить его в код, но этот полезный прием надо знать

 string testName = MethodBase.GetCurrentMethod().Name;
 try
 {
 SimpleParser p = new SimpleParser();
 int result = p.ParseAndSum(string.Empty);
 if(result!=0)
 {
 // Вызываем вспомогательный метод
 TestUtil.ShowProblem(testName,
 “ParseAndSum должен вернуть 0 для пустой строки”);
 }
 }
 catch (Exception e)
 {
 TestUtil.ShowProblem(testName, e.ToString());
 }
}

```

В каркасах автономного тестирования вспомогательные методы
носят более общий характер, поэтому и тесты писать проще. Об этом
мы будем говорить в главе 2. Но перед тем как отправиться туда, хотелось бы обсудить еще один важный вопрос: не как писать автономный тест, а когда на протяжении этапа разработки делать это. Вот тутто в игру и вступает методика разработки через тестирование.